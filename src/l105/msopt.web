@* msopt.

\begin{verbatim}
 Driver for geometry optimization using the method of Murtaugh,
 Sargent, Comp. Jour., 13, 185 (1970).  The routine nextx,
 implementing the algorithm, is qcpe 283 written by N. S. Ertz.

    options used --

    iop(6) ... maximum number of steps
    0 ... min(20,nvar+10)
    n ... n

    iop(7)  convergence on the first derivative
      and estimated displacement for the optimization:
      rms first derivative .lt. confv,
      rms est. displacement .lt. convx=4*thresh
    0 ... thresh = 0.0003 hartre/bohr or radian
    n ... thresh = 0.001 / n

    iop(10) ... initial second derivative matrix
    0 ... idenity
    3 ... read the initial second derivatives from the guess file
    4 ... use analytical second derivatives

    iop(32) ... save option
    0 ... do nothing
    1 ... write the final second derivative matrix to the ges file



 /ctests/ is explained in nextx and is initialized by subroutine
 tests.


/grdnt/ is used for the communitcation of derivative information
        from gaussian 80 to the murtaugh-sargent program.  note
        that g is forces (-de/dx).  see subroutine optmz in
        l103 for documentation of the common block.


/msinfo/ contains the data local to l105.  this data is
         documented, for the most part, in subroutine
         nextx.
\end{verbatim}

\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[OUTPUT:] JUMP                                                      
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    CALCFC  FRCNST  G       ISTEP                          
\item[Transmits as argument]  ALPHA   F       FLAST   GLAST   IANZ    IOP     LBL    
             NSTEP   NVAR    NZ      P       Q       S       THRESH 
             TOANG   X       XLAST   XNAME   Z                      
\item[Uses]  ALPHA   CALCFC  F       FLAST   FRCNST  G       GLAST  
             IANZ    IERR    IOP     IOUT    ISTEP   LBL     NSTEP  
             NVAR    NZ      P       Q       S       THRESH  TOANG  
             X       XLAST   XNAME   Z                              
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       ANALFC  BINWT   CONTST  DRUM    GABS    GFLOAT  GMAX1  
             GSQRT   ILSW    INITMS  INV     LNK1E   MSPRNT  NEXTX  
             PRMTBL  TESTS   TREAD   TWRITE  UDMS                   
\item[Called by]   L105                                                   
                                                                    
\end{description}
@a
      subroutine msopt(JUMP)
      implicit none
      double precision Alph , Alpha , Beta , Bl , Delta1 , Delta2 , 
     &                 dmax , Epsiln , F , Fconv , Flast , Flowb , 
     &                 fmax , Frcnst , G , gabs , gfloat , Gkm1p , 
     &                 Glast , gmax1
      double precision Gnorm , gsqrt , P , Pc , Pnorm , Q , rmsd , 
     &                 rmsf , S , Stpmin , Thresh , Toang , X , xd , 
     &                 xdispl , xf , Xlast , Xname , Z , zero
      integer i , iad2 , Ianz , Idnts , idx , Ierr , Igo , igrd , 
     &        Iguess , ihdg , In , iogrd , ioms , Iop , iotest , Iout , 
     &        iozmat , Ipunch , is , Istep
      integer Istype , itype , Iz , j , JUMP , Lalpha , Lbeta , Lbl , 
     &        lgrd , lms , ltest , lzmat , Ndum , Ndum2 , Ndumm , nel , 
     &        Nstep , Nvar , Nvarrd , Nz
      logical contst , Calcfc
      dimension xdispl(50) , itype(50)
      dimension is(100) , iad2(50)
      common /iop   / Iop(50)
      common /phycon/ Toang , Pc(29)
      common /ctests/ Alpha , Delta1 , Delta2 , Epsiln , Stpmin , 
     &                Fconv , Flowb , Gkm1p , Pnorm , Gnorm , Idnts , 
     &                Iguess , Ierr , Igo , Istype , Ndum
      common /grdnt / F , G(50) , Frcnst(1275) , Nvar , Ndumm
      common /msinfo/ Flast , X(50) , Xlast(50) , Xname(100) , Glast(50)
     &                , S(50,50) , P(50) , Q(50) , Z(50) , Istep , 
     &                Nstep , Thresh , Calcfc , Ndum2
      common /io    / In , Iout , Ipunch
      common /zmat  / Ianz(50) , Iz(50,4) , Bl(50) , Alph(50) , Beta(50)
     &                , Lbl(50) , Lalpha(50) , Lbeta(50) , Nz , Nvarrd
      data zero/0.0D0/
      data itype/50*98/
      data iogrd , lgrd , ioms , lms , iotest , ltest , iozmat , 
     &     lzmat/511 , 1327 , 574 , 2904 , 576 , 13 , 507 , 351/
C
C
99001 format (1H0,36(2HMS)/1H0,'MURTAUGH-SARGENT OPTIMIZATION')
99002 format (1H0,'INITIALIZATION PASS')
99003 format (1H0,36(2HMS)/)
99004 format (1H0,'CONVERGANCE UNLIKELY -- IERR=+1'/)
C
C
      call drum
      write (Iout,99001)
C
C      if this is the initial entry then no gradient is available and
C      we just take care of some initialization.
C
      call ilsw(2,23,igrd)
      if ( igrd.ne.0 ) then
C
C      normal entry.
C
C
C      read data from r/w files.
C      convert from forces to derivatives before calling nextx.
C
         call tread(iogrd,F,lgrd,1,lgrd,1,0)
         call tread(ioms,Flast,lms,1,lms,1,0)
         call tread(iotest,Alpha,ltest,1,ltest,1,0)
         Istep = Istep + 1
         do 50 i = 1 , Nvar
            G(i) = -G(i)
 50      continue
C
C      on the first step, check to see if analytical second derivatives
C      are available.
C
         if ( Calcfc ) then
            Calcfc = .false.
            call analfc(Nvar,Frcnst,S)
         endif
C
         call nextx(X,Xlast,G,Glast,S,P,Q,Z,F,Flast,Nvar,50)
C
C      compute the displacement, root mean square force, maximum force,
C      root mean square displacement, and maximum displacement.
C
         rmsf = zero
         fmax = zero
         rmsd = zero
         dmax = zero
         do 100 i = 1 , Nvar
            xdispl(i) = X(i) - Xlast(i)
            xd = gabs(xdispl(i))
            dmax = gmax1(dmax,xd)
            rmsd = rmsd + xd*xd
            xf = gabs(G(i))
            fmax = gmax1(fmax,xf)
            rmsf = rmsf + xf*xf
 100     continue
         rmsf = gsqrt(rmsf/gfloat(Nvar))
         rmsd = gsqrt(rmsd/gfloat(Nvar))
C
C      print a summary of the point.
C
         call msprnt(Nvar,Istep,Nstep,X,Xlast,xdispl,G,S,Xname)
C
C      when nextx detects that convergence is unlikely it sets ierr=+1.
C
         if ( Ierr.eq.+1 ) then
            write (Iout,99004)
            write (Iout,99003)
            call lnk1e
         endif
C
C      do convergence testing via the logical function contst.
C
         if ( .not.contst(Iop,Istep,Nvar,rmsf,fmax,rmsd,dmax,Nstep,
     &        Thresh,ihdg) ) then
C
C
C      update the r/w files and return to g80.
C
            do 120 i = 1 , Nvar
               G(i) = -G(i)
 120        continue
            call twrite(ioms,Flast,lms,1,lms,1,0)
            call twrite(iotest,Alpha,ltest,1,ltest,1,0)
            call twrite(iogrd,F,lgrd,1,lgrd,1,0)
            call udms(X,Nvar)
            write (Iout,99003)
            JUMP = 0
         else
            call tread(iozmat,Ianz,lzmat,1,lzmat,1,0)
            call prmtbl(ihdg,Xname,Xlast,itype,G,Nvar,Lbl,Nz,Toang)
            write (Iout,99003)
C
C      write the second derivative matrix to the ges file if this
C      was requested.
C
            if ( Iop(32).ne.0 ) then
               nel = 200
               call binwt(Xname,nel,16HVARIABLE NAMES  ,0)
               call inv(S,Nvar,is,itype,iad2,xdispl,50)
               idx = 0
               do 130 i = 1 , Nvar
                  do 125 j = 1 , i
                     idx = idx + 1
                     Frcnst(idx) = S(i,j)
 125              continue
 130           continue
               nel = Nvar*(Nvar+1)
               call binwt(Frcnst,nel,16HFORCE CONSTANTS ,0)
            endif
            JUMP = 1
         endif
      else
         write (Iout,99002)
         call ilsw(1,23,1)
         call initms(Iop,Xname,X,Nvar,Istep,Nstep,S,Thresh,Calcfc,Toang,
     &               Frcnst)
         call tests
         call twrite(ioms,Flast,lms,1,lms,1,0)
         call twrite(iotest,Alpha,ltest,1,ltest,1,0)
         call twrite(iogrd,F,lgrd,1,lgrd,1,0)
         write (Iout,99003)
         JUMP = 0
      endif
C
C
      return
C
      end
@* INDEX.
