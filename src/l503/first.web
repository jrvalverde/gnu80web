@* first.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[PASSED:] NSYMOP                                                    
\item[PASSED:] NEQBAS                                                    
\item[OUTPUT:] JCYCLE                                                    
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    A       ACURCY  B       CLASS   CRIT    DERIV   ENERGY 
             ITCNT   KSPIN   MAXCYC  NEST    NEST1   NSE     NSEP   
             SKPSYM  X       XL      Y                              
\item[Transmits as argument]  CMP     DD      E       IEVAL   IEVALS  IGENO   IOC    
             IOC0    IOCS    IOD     IOF1P   IOF1T   IOFA    IONE   
             IOQ     IOV     JMAT    LIGEN   MDIM    MTT     NBASIS 
             NTT                                                    
\item[Uses]  A       B       BIG     CLASS   CMP     DD      DERIV  
             E       ENERGY  EXTRAP  IEVAL   IEVALS  IGENO   IN     
             IOC     IOC0    IOCS    IOD     IOF1P   IOF1T   IOFA   
             IONE    IOP     IOQ     IOUT    IOV     ITCNT   JMAT   
             KEY     KSM     KSPIN   KSW     LIGEN   LTAU    MAXCYC 
             MDIM    MSHIFS  MTT     NAE     NBASIS  NBE     NESK   
             NEST    NEST1   NSE     NSEP    NSK     NTT     ONE    
             PT5     RHF     RMS     SMALL   X       XL      Y      
             ZERO                                                   
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       ASGSYM  AUFBAU  BESSRT  CMAT    CONUSO  CPULFT  CPUTIM 
             CSYMM   DIABLO  DIAGD   FORMF   GABS    GFLOAT  GMAX1  
             GSIGN   GSQRT   ILSW    LNK1E   LOCMIN  MATMUL  OFIX   
             PMAT    SLS     TIOC    TREAD   TWRITE                 
\item[Called by]   SCFDM                                                  
                                                                    
\end{description}
@a
      subroutine first(NSYMOP,NEQBAS,JCYCLE)
      implicit none
      double precision A , a0 , a1 , a2 , a3 , Acurcy , Atmchg , B , 
     &                 beta , Big , C , cpulft , Crit , Dd , delta , 
     &                 Deriv , Dfl , Dsr , dtime , Dumscr
      double precision E , ea , efph , eh , ehsav , elen , elm , 
     &                 Energy , ensav , esav , etime , Fillab , Four , 
     &                 gabs , gfloat , gmax1 , gnorm , gsav , gsign , 
     &                 gsqrt
      integer i , i0 , i1 , i1i , i1r , i2 , ia , Ian , Icharg , icls , 
     &        icon , iconv , Icount , icy , idm2 , idmet , Idscr , 
     &        idump , ierr , Ieval
      integer Ievals , iexp , Ifill , Igeno , iguess , ii , im , In , 
     &        Ioc , Ioc0 , Iocs , Iod , Iof1p , Iof1t , Iofa , Ione , 
     &        Iop , Ioq , iord2 , Ios
      integer Iouab , Ious , Iout , Iov , ipart , Iperm , ipfm , 
     &        ipliml , iplimu , iprint , Ipspin , Iptot , Ipunch , ir , 
     &        iss , isym , itauf , Itcnt , j , jcnt
      integer JCYCLE , Jmat , keycon , Ksm , Kspin , Ksw , Lehf , 
     &        Ligen , Lilsw , Lipcw , lm , lm1 , lmm , lmp , Lrep , 
     &        Lrmsd , Ls2 , Ltau , Lten , Lvir
      integer m1 , m2 , MAXBAS , Maxcyc , maxint , maxord , maxpt , 
     &        md2 , Mdim , mdm , Mdsq , mexit , minint , minprt , 
     &        minpt , mint , mord , mord1 , Mshifs , msp
      integer mtd , Mtt , mtt1 , Multip , Nae , Natoms , nb2 , Nbasis , 
     &        Nbe , Ne , NEQBAS , Nesk , Nest , Nest1 , ng , np , np1 , 
     &        Nse , Nsep , Nsk
      integer NSYMOP , Ntt
      double precision One , Onept5 , Pt5 , ptime , q , Rms , rmsav , 
     &                 rmthrd , rmthrs , scalt , scalt0 , scaltd , 
     &                 smald , Small , tau , tau0 , tau1 , tau2 , 
     &                 Three , time0
      double precision Two , X , xi , Xl , xlam , xlambd , Y , ymin , 
     &                 Zero
      parameter (MAXBAS=150)
      dimension NEQBAS(MAXBAS,8)
C      real cputim,cpulft,ptime,etime,dtime,time0
      real cputim
      logical conju , minver , nomin , methc , Key , Cmp , Rhf , cd , 
     &        Class , Extrap
      logical Skpsym
      dimension Dd(70) , Iperm(70) , elen(2) , xlambd(10) , elm(10) , 
     &          Nsk(2)
      dimension etime(3)
      common /iop   / Iop(50)
      common /mol   / Natoms , Icharg , Multip , Nae , Nbe , Ne , 
     &                Nbasis , Ian(101) , Atmchg(100) , C(300)
      common /con503/ Zero , Pt5 , One , Onept5 , Two , Three , Four , 
     &                Big , Small
      common /scfcon/ Cmp , Rhf , Ksm , Kspin , Ksw(2) , Nesk(2) , Nse , 
     &                Nsep , Nest , Nest1
      common /maxdm / Mdim , Mtt , Ntt , Mdsq , Mshifs
      common /memry / A(4970) , B(4970) , Fillab(40060)
      common /io    / In , Iout , Ipunch
      common /rwf503/ Igeno , Ieval , Ios , Ione , Iofa(4) , Iod(4) , 
     &                Ioc(4) , Iocs(4) , Ioc0(4) , Ioq(4) , Ious(4) , 
     &                Jmat(4) , Iof1p(4) , Ievals , Iouab(4) , Iptot(2)
     &                , Ipspin(2)
      common /cut   / Energy , Deriv , Acurcy , Rms , Maxcyc , Icount , 
     &                Class , Extrap
      common /scr   / X(10,10) , Y(10) , Xl(10) , Dfl(20) , Dsr(140) , 
     &                E(140) , Key , Itcnt , Crit , Skpsym , Idscr , 
     &                Dumscr(5209) , Ifill
      common /lge503/ Lilsw , Lipcw , Ltau , Lehf , Lvir , Lrep , Lten , 
     &                Ls2 , Ligen , Lrmsd
      equivalence (Nsk(1),Nae)
      equivalence (Dd(1),B(4901))
      equivalence (Iperm(1),X(1,1))
      equivalence (Iof1t,Iof1p(1)) , (Ioc(1),Iov)
      data rmthrd/1.D-3/
      data tau2 , mdm , mord1 , maxord , maxpt/.3D0 , 10 , 9 , 9 , 10/
      data scaltd/2.1D0/
      data smald/1.D-18/
      data dtime/120./
C
C     ******************************************************************
C     this routine solves the pople nesbet equations by means of a
C     direct energy minimization procedure, involving a sequence of
C     univariate searches
C     it is called by the main program scfdm
C
C     the following procedures are implemented:
C     - conjugate directions
C     - steepest descent
C     - classical scf
C
C     the following values for q are programmed:
C     - q = 0. (method b)
C     - q read in
C
C     coded in 75 by rs9b
C     ******************************************************************
C
C=ia  common/cut/energy,deriv,acurcy,maxcyc,rms,icount,class,extrap
C
C
C     threshold for delta(trace p) to switch from d.m. to classical scf
C=nr  data jrdmax/6/
C
99001 format (2I1,g18.5,2G20.5)
99002 format (40I2)
99003 format (g16.10)
99004 format (1x,72(1H*),/,1x,'CYC',1x,'PT',5x,'ELECTRONIC ENERGY',3x,
     &        'CONVERGENCE',1x,'PTS/DEG',2x,'LAMBDA',5x,'(DE/DL)',/,1x,
     &        72('*'))
99005 format (56(1H*)/1x,5HCYCLE,5x,17HELECTRONIC ENERGY,5x,
     &        11HCONVERGENCE,2x,7HEXTRAP./56(1H*))
99006 format (' STEEPEST DESCENT')
99007 format (1x,i4,4x,d22.15)
99008 format (1x,i3,'(',i2,')',1x,d22.15)
99009 format (' ',61x,d11.4)
99010 format (1x,19(1H*)/' *ITERATION ABORTED*'/1x,19(1H*))
99011 format (' TAU(0)=',f7.4,6x,'MAX. DEGREE OF SEARCH POLYNOMIAL=',i2)
99012 format (' M.O. COEFFICIENTS ',a6/1x,17(1H*))
99013 format (' F(1),T'/1x,6(1H*))
99014 format (1x,i4,5x,17H(NON-VARIATIONAL))
99015 format (1x)
99016 format (' CONJUGATE DIRECTIONS')
99017 format (' ',42x,2I3,1x,d11.4)
99018 format (' ',25x,'METHOD B')
99019 format (' ',25x,'METHOD WITH GENERAL Q')
99020 format (' MAX-TIME EXIT')
99021 format (' ',49x,d11.4)
99022 format (' ALTERNATE TRIAL WAVEFUNCTION (TAU POSITIVE)'/1x,43('*'))
99023 format (' TAU NEGATIVE'/1x,12(1H*))
99024 format (' *** ENERGY RISES ***')
99025 format (' REPEAT THE PREVIOUS SEARCH WITH TAU =',d26.12)
99026 format (' CLASSICAL SCF')
99027 format (' ')
C     ******************************************************************
      idmet = Iop(8)
      icls = Iop(9)
      iexp = Iop(11)
      iord2 = Iop(14)
      itauf = Iop(15)
      ipfm = Iop(19)
      mexit = Iop(20)
      iprint = Iop(33)
      idump = Iop(34)
C
      call ilsw(2,21,minprt)
      idm2 = idmet/2
      call ilsw(2,7,isym)
      call ilsw(2,1,icon)
      icon = icon + 1
      call ilsw(2,8,iguess)
C
      ipart = 1
      if ( Cmp ) ipart = 2
      mtd = Mtt + Mtt
      mtt1 = Mtt + 1
      md2 = Ksm*Mdim
      nb2 = Ksm*Nbasis
      gsav = One
      iss = 0
      iconv = 0
      ensav = Zero
C
C     read in search parameters
      mord = 0
      minpt = 0
      tau1 = Zero
      scalt0 = Zero
      q = Zero
      if ( mod(idmet,2).ne.0 ) read (In,99001) mord , minpt , tau1 , 
     &                               scalt0 , q
      if ( mord.eq.0 ) mord = mord1
      mord = min0(mord,maxord)
      mord = max0(mord,2)
      minpt = min0(minpt,mord)
      minpt = max0(minpt,2)
      tau0 = tau2
      if ( iguess.ne.0 ) then
         call tread(Igeno,A,Ligen,1,Ligen,1,0)
         if ( A(Ltau).gt.Small ) tau0 = A(Ltau)
      endif
      if ( tau1.gt.Zero ) tau0 = tau1
      scalt = scaltd
      if ( scalt0.gt.Zero ) scalt = scalt0
C
      msp = minpt*mord
      minint = minpt - 1
      maxint = maxpt
C
C     set limits for printout of f(1),t
      ipliml = 1000
      iplimu = 0
      if ( ipfm.ne.0 ) read (In,99002) ipliml , iplimu
      if ( iplimu.eq.99 ) iplimu = 1000
C
C     define switch threshold (d.m. to classical scf)
      rmthrs = rmthrd
      if ( icls.eq.2 ) read (In,99003) rmthrs
C
C     define method
      Class = .false.
      if ( idm2.eq.1 ) Class = .true.
      conju = .false.
      methc = .false.
      if ( .not.(Class) ) then
         if ( idm2.eq.2 ) conju = .true.
         if ( gabs(q).gt.Zero ) methc = .true.
         if ( .not.conju ) write (Iout,99006)
         if ( conju ) write (Iout,99016)
         if ( .not.methc ) write (Iout,99018)
         if ( methc ) write (Iout,99019)
         write (Iout,99011) tau0 , mord
      endif
      if ( Class ) write (Iout,99026)
      if ( isym.ne.0 ) write (Iout,99023)
      if ( .not.Class .and. minprt.eq.0 ) write (Iout,99004)
      if ( Class .and. minprt.eq.0 ) write (Iout,99005)
C
C     load the proper set of m.o. coefficients into ioc
 100  if ( iss.ne.0 ) then
         do 150 Kspin = 1 , Ksm
            call tioc(Nbasis,2,Iocs,B,4,1,idump)
            call tioc(Nbasis,2,Ioc,A,4,1,idump)
            call tioc(Nbasis,1,Ioc,B,4,1,idump)
            call tioc(Nbasis,1,Iocs,A,4,1,idump)
 150     continue
      endif
C
C     ******************************************************************
C     head of the loop over the univariate searches
C     ******************************************************************
C
C
C
      JCYCLE = -1
      Skpsym = .true.
      nomin = .true.
      minver = .true.
      mint = minint
      do 200 i = 1 , 3
         etime(i) = 0.0D00
 200  continue
C
C     ******************************************************************
C     generate density matrix and test for convergency
C     ******************************************************************
C
 300  JCYCLE = JCYCLE + 1
C     check orthonormality of input wavefunction
      ierr = 0
      if ( (JCYCLE.eq.0) .or. (Iop(21).eq.2) )
     &     call ofix(Nbasis,ierr,idump)
      if ( ierr.ne.0 .and. Iop(21).eq.0 ) call lnk1e
      m1 = 1
      do 400 Kspin = 1 , Ksm
         Nse = Nsk(Kspin)
         call tioc(Nbasis,2,Ioc,B,4,1,idump)
         call pmat(Nbasis,B,A)
         call tioc(Nbasis,1,Iod,A(m1),2,1,idump)
         m1 = m1 + Mshifs
 400  continue
      if ( JCYCLE.eq.0 ) call conuso(Nbasis,iexp,keycon,1,idump)
      if ( JCYCLE.ne.0 ) call conuso(Nbasis,iexp,keycon,2,idump)
      if ( keycon.eq.0 ) goto 1900
      if ( JCYCLE.ne.0 ) then
         ptime = 0.0D00
         do 450 i = 1 , 3
            ptime = gmax1(ptime,etime(i))
 450     continue
         ptime = ptime + dtime
         if ( mexit.eq.0 ) ptime = 0.
         if ( cpulft(i).le.ptime ) then
            write (Iout,99020)
            goto 1800
         endif
      endif
C
      time0 = cputim(i)
      if ( JCYCLE.gt.Maxcyc ) goto 1800
C
C     initiate the pattern of v(xlam),p  (unit matrix)
      if ( .not.(Class) ) then
         call bessrt(Nbasis,1,tau,A,B,Mdim,idump)
C
C     clear xlambd, esav and jcnt
         do 500 i = 1 , maxpt
            xlambd(i) = Zero
 500     continue
      endif
      esav = Zero
      jcnt = 0
      lm = 1
C
C     ******************************************************************
C     computation of the a.o. fock matrices, and the electronic energy
C     ******************************************************************
C
 600  eh = Zero
      efph = Zero
C
C     read density matrix
      m1 = 1
      do 700 Kspin = 1 , Ksm
         if ( lm.eq.1 ) then
C
            call tioc(Nbasis,2,Iod,A(m1),2,1,idump)
         else
            Nse = Nsk(Kspin)
            call tioc(Nbasis,2,Ioc,B,4,1,idump)
            call pmat(Nbasis,B,A)
            call tioc(Nbasis,1,Iod,A(m1),2,1,idump)
         endif
         m1 = m1 + Mshifs
 700  continue
C
C     one-electron energy
      m1 = 1
      do 800 Kspin = 1 , Ksm
         call tread(Ione,B(m1),Mtt,1,Ntt,1,0)
         if ( Cmp ) then
            m2 = m1 + Mtt - 1
            do 720 i = 1 , Ntt
               B(m2+i) = Zero
 720        continue
         endif
C
C     trace (p*h)
         a0 = A(m1)
         call matmul(Nbasis,A(m1),B(m1),0,2,2)
         eh = eh + A(m1)
         A(m1) = a0
         m1 = m1 + Mshifs
 800  continue
C
      call formf(Nbasis,Ione,Iod,NSYMOP,NEQBAS)
C
C     total electronic energy
      m1 = 1
      do 900 Kspin = 1 , Ksm
         call tioc(Nbasis,1,Iofa,B(m1),2,1,idump)
         call tioc(Nbasis,2,Iod,A(m1),2,1,idump)
         call matmul(Nbasis,A(m1),B(m1),0,0,2)
         efph = efph + A(m1)
         m1 = m1 + Mshifs
 900  continue
      Energy = Pt5*(eh+efph)
      if ( minprt.eq.0 ) then
         if ( Extrap ) write (Iout,99014) JCYCLE
         if ( .not.(Extrap .and. iprint.lt.3) ) then
            if ( Class ) write (Iout,99007) JCYCLE , Energy
            if ( .not.Class ) write (Iout,99008) JCYCLE , lm , Energy
         endif
      endif
      lmm = mod(lm-1,maxpt) + 1
      elm(lmm) = Energy
C
C
C     ******************************************************************
C     the following part is performed for the first point of each
C     univariate search only
C     ******************************************************************
C
C
      if ( minver ) then
         minver = .false.
C
C     ****************************************************************
C     numerical stability test (finite step size tau)
C     ******************************************************************
C
C     prevent two subsequent cycles with rising energy (due to finite
C     mesh size for univariate search)
         if ( .not.(Class .or. JCYCLE.le.1) ) then
            if ( ensav.le.Energy-Small ) then
               write (Iout,99024)
               icls = 0
               Energy = ensav
               eh = ehsav
               elm(1) = Energy
               mint = maxint
               tau = tau/gfloat(mint)
               tau = gsign(tau,-Deriv)
               JCYCLE = JCYCLE - 1
               write (Iout,99025) tau
               write (Iout,99008) JCYCLE , lm , Energy
               goto 1100
            endif
         endif
C
         ensav = Energy
         ehsav = eh
         rmsav = Rms
         if ( .not.(.not.(Rms.lt.rmthrs .and. icls.ne.0 .and. JCYCLE.ge.
     &        1) .or. Class) ) then
            Class = .true.
            if ( minprt.eq.0 ) write (Iout,99005)
            write (Iout,99015)
         endif
C
C     correct tau if desired
         mint = mint - 1
         mint = max0(mint,minint)
         tau = tau0
         if ( JCYCLE.gt.0 .and. itauf.eq.0 )
     &        tau = scalt*xlam/gfloat(mint)
C
C     put the appropriate m.o. coefficient matrix into ioc0
         do 950 Kspin = 1 , Ksm
            call tioc(Nbasis,2,Ioc,A,4,1,idump)
            if ( iprint.ge.3 ) then
               write (Iout,99012) Ksw(Kspin)
               call cmat(A,Mdim,Mdim,Nbasis,Nbasis,Cmp)
            endif
            call tioc(Nbasis,1,Ioc0,A,4,1,idump)
 950     continue
C
C     ******************************************************************
C     evaluate the fock matrix in terms of the pseudocanonical basis
C     get  f(0),p, the q matrix and the diagonal matrix epsylon
C     check whether the q matrix has the demanded block structure
C     or not and reorder if desired (default)
C     ******************************************************************
C
         do 1000 Kspin = 1 , Ksm
            Nest = Nesk(Kspin)
            Nse = Nsk(Kspin)
            Nest1 = Nest + 1
            Nsep = Nse + 1
C
C     evaluate f(1),t  (eqn. 13)
            call tioc(Nbasis,2,Iofa,A,3,1,idump)
            call tioc(Nbasis,2,Ioc0,B,4,1,idump)
            call matmul(Nbasis,A,B,0,0,0)
            call matmul(Nbasis,A,B,1,0,0)
            call asgsym(Nbasis,A,B,Mdim)
            call tioc(Nbasis,1,Iof1t,A,3,1,idump)
            if ( .not.(Class) ) then
C
C     pack f(1),t
               call sls(1,A,Mdim,Nbasis)
               if ( JCYCLE.le.iplimu .and. JCYCLE.ge.ipliml ) then
                  write (Iout,99013)
                  call csymm(A,Mdim,Nbasis,Cmp)
                  write (Iout,99027)
               endif
C
C     compute f(0),t by deleting the off-diagonal blocks of f(1),t and
C     spectrum of f(0),t  (eqns. 14 - 17)
               call diablo(Nbasis,E(Nest1),Dd,X)
               call tioc(Nbasis,1,Ioq,B,4,1,idump)
C
C     form f(1),p  (eqn. 18)
               call tioc(Nbasis,2,Iof1t,A,3,1,idump)
               call matmul(Nbasis,A,B,0,0,0)
               call matmul(Nbasis,A,B,1,0,0)
               call tioc(Nbasis,1,Iof1p,A,3,1,idump)
            endif
 1000    continue
         Skpsym = .false.
         if ( Class ) then
C
C     ******************************************************************
C     classical scf (roothaan's method of repeated diagonalization)
C     ******************************************************************
C
            do 1020 Kspin = 1 , Ksm
               Nest1 = Nesk(Kspin) + 1
               call tioc(Nbasis,2,Iof1t,A,2,1,idump)
               call diagd(A,B,E(Nest1),Nbasis,Dd,X,Mdim,Cmp)
               call tioc(Nbasis,2,Ioc0,A,4,1,idump)
               call matmul(Nbasis,A,B,0,0,0)
               call tioc(Nbasis,1,Ioc,A,4,1,idump)
 1020       continue
            minver = .true.
            call twrite(Ieval,E,nb2,1,nb2,1,0)
            goto 300
         else
C
            call twrite(Ieval,E,nb2,1,nb2,1,0)
C
C     ******************************************************************
C     delta  (eqn. 33)
C     gnorm  (for conjugate directions, not in paper)
C     ******************************************************************
C
            delta = Zero
            gnorm = Zero
            a0 = One
C
            do 1040 Kspin = 1 , Ksm
               Nest = Nesk(Kspin)
               Nse = Nsk(Kspin)
               Nsep = Nse + 1
               call tioc(Nbasis,2,Iof1p,A,2,1,idump)
               do 1030 ia = Nsep , Nbasis
                  i1r = ia*(ia-1)/2
                  i1i = i1r + Mtt
                  ea = E(ia+Nest)
                  do 1025 ii = 1 , Nse
                     a1 = ea - E(ii+Nest)
                     if ( methc ) a0 = a1**q
                     if ( Cmp ) gnorm = gnorm + (a0*A(i1i+ii))**2
                     gnorm = gnorm + (a0*A(i1r+ii))**2
                     delta = delta + a0
 1025             continue
 1030          continue
 1040       continue
C
            delta = delta/gfloat(Nae*(Nbasis-Nae)+Nbe*(Nbasis-Nbe))
            if ( Rhf ) then
               gnorm = gnorm + gnorm
               delta = delta + delta
            endif
            gnorm = gsqrt(gnorm)/delta
C
C     ******************************************************************
C     (de/dxlam)  (eqn. 31)
C     j matrix  (eqn. 32)
C     ******************************************************************
C
            Deriv = Zero
            eh = Zero
            beta = gnorm/gsav
            gsav = gnorm
            cd = conju .and. .not.nomin
            a0 = One
C
            do 1060 Kspin = 1 , Ksm
               Nest = Nesk(Kspin)
               Nse = Nsk(Kspin)
               Nsep = Nse + 1
               call tioc(Nbasis,2,Iof1p,A,2,1,idump)
               if ( cd ) call tioc(Nbasis,2,Jmat,A(Mshifs+1),2,1,idump)
               i0 = 0
               do 1050 icy = 1 , ipart
                  do 1045 ia = Nsep , Nbasis
                     ea = E(ia+Nest)
                     i1 = i0 + ia*(ia-1)/2
                     i2 = i1 + Mshifs
                     do 1042 ii = 1 , Nse
                        ir = i1 + ii
                        a1 = ea - E(ii+Nest)
                        if ( methc ) a0 = a1**q/delta
                        a2 = A(ir)
                        a3 = a2*a0
                        if ( cd ) a3 = a3 + beta*A(i2+ii)
                        Deriv = Deriv - a2*a3/a1
                        A(ir) = a3
                        eh = eh + a3**2
 1042                continue
 1045             continue
                  i0 = Mtt
 1050          continue
               call tioc(Nbasis,1,Jmat,A,2,1,idump)
 1060       continue
            Deriv = Deriv + Deriv
            if ( Rhf ) then
               Deriv = Deriv + Deriv
               eh = eh + eh
            endif
            if ( cd ) then
C
C     for conjugate directions, normalize the direction to the length of
C     the uncorrected gradient
               beta = gnorm/gsqrt(eh)
               Deriv = Deriv*beta
               do 1070 Kspin = 1 , Ksm
                  Nse = Nsk(Kspin)
                  Nsep = Nse + 1
                  call tioc(Nbasis,2,Jmat,A,2,1,idump)
                  do 1065 ia = Nsep , Nbasis
                     i1r = ia*(ia-1)/2
                     i1i = i1r + Mtt
                     do 1062 ii = 1 , Nse
                        ir = i1r + ii
                        A(ir) = A(ir)*beta
                        if ( Cmp ) then
                           im = i1i + ii
                           A(im) = A(im)*beta
                        endif
 1062                continue
 1065             continue
                  call tioc(Nbasis,1,Jmat,A,2,1,idump)
 1070          continue
            endif
            if ( minprt.eq.0 ) write (Iout,99009) Deriv
            if ( gabs(Deriv).lt.smald ) goto 1900
C
C     establish the proper value and sign for tau
            if ( tau*Deriv.gt.Zero ) tau = tau0
            tau = gsign(tau,-Deriv)
         endif
      endif
C
C
C     ******************************************************************
C     the following section is used for each point of the univariate
C     search
C     ******************************************************************
C
C
 1100 lm = lm + 1
      if ( esav.lt.Energy .and. lm.gt.minpt ) goto 1600
      esav = Energy
      if ( lm.gt.msp ) goto 1600
C
C     ******************************************************************
C     get the transformation matrix at xlam>0. , v(xlam),p  and reorder
C     it if necessary and desired
C     ******************************************************************
C
      lmm = mod(lm-1,maxpt) + 1
      lmp = mod(lm-2,maxpt) + 1
      Itcnt = 0
 1200 Itcnt = Itcnt + 1
      xlam = xlambd(lmp) + tau
      xlambd(lmm) = xlam
      Crit = Big
C
 1300 do 1400 Kspin = 1 , Ksm
         Nest = Nesk(Kspin)
         Nse = Nsk(Kspin)
         Nest1 = Nest + 1
         Nsep = Nse + 1
C
C     form f(xlam),p  (eqn. 23)
         call tioc(Nbasis,2,Jmat,A,2,1,idump)
         do 1350 ia = Nsep , Nbasis
            i1r = ia*(ia-1)/2
            i1i = i1r + Mtt
            do 1320 ii = 1 , Nse
               ir = i1r + ii
               A(ir) = A(ir)*xlam
               if ( Cmp ) then
                  im = i1i + ii
                  A(im) = A(im)*xlam
               endif
 1320       continue
 1350    continue
C
C     spectrum of f(xlam),p  (eqn. 24)
         call diagd(A,B,E(Nest1),Nbasis,Dd,X,Mdim,Cmp)
         call tioc(Nbasis,1,Iov,B,4,1,idump)
         if ( iord2.le.1 ) call bessrt(Nbasis,iord2+2,tau,A,B,Mdim,
     &                                 idump)
         if ( Key ) goto 1200
 1400 continue
      if ( .not.minver .and. minprt.eq.0 ) write (Iout,99021) xlam
C
C     ******************************************************************
C     orthogonality transformation of the m.o. coefficients  (eqn. 25)
C     ******************************************************************
C
      do 1500 Kspin = 1 , Ksm
         Nest = Nesk(Kspin)
         Nse = Nsk(Kspin)
C
C     form the transformation matrix  q * v(xlam),p
         if ( iord2.gt.1 ) then
C
            call tioc(Nbasis,2,Iov,B,4,1,idump)
         else
            call tioc(Nbasis,2,Iov,A,4,1,idump)
            call bessrt(Nbasis,4,tau,A,B,Mdim,idump)
         endif
         call tioc(Nbasis,2,Ioq,A,4,1,idump)
         call matmul(Nbasis,A,B,0,0,0)
C
C     transform the m.o. coefficients
         call tioc(Nbasis,2,Ioc0,B,4,1,idump)
         call matmul(Nbasis,B,A,0,0,0)
         call tioc(Nbasis,1,Ioc,B,4,1,idump)
 1500 continue
C
      i = mod(JCYCLE,2) + 1
      etime(i) = cputim(i) - time0
      if ( .not.(minver) ) goto 600
      goto 300
C
C     ******************************************************************
C     calculate the search polynomial and its lowest local minimum
C     ******************************************************************
C
 1600 if ( lm.gt.maxpt ) then
C
         lm1 = lm - 1
         np = maxpt
         ng = np - 1
         mint = lm - maxpt
         m1 = mint - 1
         do 1650 i = mint , lm1
            i1 = mod(i-1,maxpt) + 1
            i2 = i - m1
            xi = xlambd(i1)
            Xl(i2) = xi
            Y(i2) = elm(i1)
            a0 = One
            X(i2,1) = One
            do 1620 j = 2 , maxpt
               a0 = a0*xi
               X(i2,j) = a0
 1620       continue
 1650    continue
      else
         np = lm - 1
         np1 = lm
         ng = np
         do 1700 i = 1 , np
            xi = xlambd(i)
            Xl(i) = xi
            Y(i) = elm(i)
            a0 = One
            X(i,1) = One
            do 1660 j = 2 , np1
               a0 = a0*xi
               X(i,j) = a0
 1660       continue
 1700    continue
         Y(np1) = Deriv
         X(np1,1) = Zero
         X(np1,2) = One
         if ( np1.ge.3 ) then
            do 1720 i = 3 , np1
               X(np1,i) = Zero
 1720       continue
         endif
      endif
C
      call locmin(ng,np,X,Y,Xl,nomin,xlam,ymin,iprint,mdm)
      if ( minprt.eq.0 ) write (Iout,99017) np , ng , xlam
      minver = .true.
      Itcnt = 0
      goto 1300
C
C     ******************************************************************
C     proceed to use the whole minimization procedure once again, this
C     time for the alternate wavefunction, provided by the second order
C     stability routines.
C     ******************************************************************
C
 1800 iconv = 1
      write (Iout,99010)
 1900 if ( isym.ne.0 ) then
         iss = iss + 1
         elen(iss) = Energy
         if ( iss.ne.2 ) then
            call tread(Ieval,E,nb2,1,nb2,1,0)
            call twrite(Ievals,E,nb2,1,nb2,1,0)
            write (Iout,99022)
            goto 100
C
C     compare the energies of the two minimized wavefunctions
         elseif ( elen(2).gt.elen(1) ) then
            call tread(Ievals,E,nb2,1,nb2,1,0)
            do 1920 Kspin = 1 , Ksm
               call tioc(Nbasis,2,Iocs,A,4,1,idump)
               call tioc(Nbasis,2,Ioc,B,4,1,idump)
               call tioc(Nbasis,1,Iocs,B,4,1,idump)
               call tioc(Nbasis,1,Ioc,A,4,1,idump)
 1920       continue
         endif
      endif
C
C     ******************************************************************
C     termination of the iteration
C     ******************************************************************
C
C     set convergence bit in the inter-link-status-word
      call ilsw(1,5,iconv)
C
C     clear symmetry bit in the inter-link-status-word
      call ilsw(1,7,0)
C
C     apply the aufbau principle
      call tread(Ieval,E,nb2,1,nb2,1,0)
      do 2000 Kspin = 1 , Ksm
         Nse = Nsk(Kspin)
         Nest = Nesk(Kspin)
         call tioc(Nbasis,2,Ioc0,B,4,1,idump)
         call aufbau(Nbasis,B,Mdim)
         call tioc(Nbasis,1,Ioc,B,4,1,idump)
 2000 continue
C
C     update ieval
      call twrite(Ieval,E,nb2,1,nb2,1,0)
C
C     save jcycle and tau for use in scfdm
      Acurcy = tau
      Maxcyc = JCYCLE - 1
C
      return
C
      end
@* INDEX.
