@* qpasy.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[INPUT:] N                                                         
\item[INPUT:] LA1                                                       
\item[INPUT:] LB1                                                       
\item[INPUT:] ALP                                                       
\item[INPUT:] XKA1                                                      
\item[INPUT:] XKB1                                                      
\item[INPUT:] IFLAG                                                     
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    ALPHA   RK      T                                      
\item[Uses]  DFAC    RK      T                                      
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       QCOMP                                                  
\item[Called by]    NOTHING                                           
                                                                    
\end{description}
@a
      function qpasy(N,LA1,LB1,ALP,XKA1,XKB1,IFLAG)
      implicit none
      real*8 ALP , Alpha , coe , cutoff , Dfac , four , one , prefac , 
     &       Q , qcomp , qnew , qold1 , qold2 , qpasy , Rk , sum , T , 
     &       term , tk , two
      real*8 xka , XKA1 , xkb , XKB1
      integer IFLAG , j , la , LA1 , lb , LB1 , N , nprime
C
C     partially asymptotic form for q(n,la1,lb1).......
C     result includes a factor exp(-xkb*xkb/(4.*alpha)) to prevent overflow
      common /qstore/ Q(9,7) , Alpha , Rk , T
      common /dfac  / Dfac(23)
      save one , two , four , cutoff
      data one/1.0D0/ , two/2.0D0/ , four/4.0D0/ , cutoff/1.0D-13/
C
C first set up xkb as largest.
      if ( IFLAG.eq.3 ) then
         xka = XKB1
         xkb = XKA1
         la = LB1
         lb = LA1
      else
         xka = XKA1
         xkb = XKB1
         la = LA1
         lb = LB1
      endif
C set up parameters for qcomp using xkb.
      Alpha = one
      Rk = xkb/sqrt(ALP)
      T = Rk*Rk/four
C
C now run power series using xka,  obtaining initial q(n,l)'s
C    from qcomp then recurring upwards.
      tk = xka*xka/(two*ALP)
C  j=0 term in sum.
      qold1 = qcomp(N+la,lb)
      sum = qold1/Dfac(la+la+3)
      if ( tk.ne.0 ) then
C  j=1 term in sum.
         nprime = N + la + 2
         qnew = qcomp(nprime,lb)
         term = qnew*tk/Dfac(la+la+5)
         sum = sum + term
C  j=2  term
         j = 2
         nprime = N + la + j + j
         coe = one/Dfac(la+la+3)
 50      qold2 = qold1*coe
         qold1 = qnew*coe
         qnew = (T+float(nprime+nprime-5)/two)
     &          *qold1 + float((lb-nprime+4)*(lb+nprime-3))*qold2/four
C    now correct qnew for j-1 and j factors.
         term = qnew*tk*tk/(float((j-1)*(la+la+j+j-1))
     &          *float(j*(la+la+j+j+1)))
         sum = sum + term
         if ( abs(term/sum).gt.cutoff ) then
C  increment j for next term
            j = j + 1
            nprime = N + la + j + j
C    compute j-2 factor to be absorbed into qold1,qold2.
            coe = tk/float((j-2)*(la+la+j+j-3))
            goto 50
         endif
      endif
      if ( la.eq.0 ) prefac = one/sqrt(ALP**(N+la+1))
      if ( la.ne.0 ) prefac = (xka**la)/sqrt(ALP**(N+la+1))
      qpasy = prefac*sum
      return
      end
@* INDEX.
