@* bessv.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[OUTPUT:] B                                                         
\item[INPUT:] Z                                                         
\item[INPUT:] L                                                         
\item[INPUT:] N                                                         
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]     NOTHING                                           
\item[Uses]  DFAC    FPROD                                          
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]        NOTHING                                           
\item[Called by]   PTPREP                                                 
                                                                    
\end{description}
@a
      subroutine bessv(B,Z,L,N)
      implicit none
      real*8 B , den , denm , denp , Dfac , f16pt1 , Fact , five , 
     &       Fprod , one , pt5 , rm , rp , term , texm , two , tzi , 
     &       tzmi , tzpi , Z
      real*8 zero , zp
      integer i , ihi1 , ihi2 , ihi3 , ilo1 , ilo2 , ilo3 , j , k1 , L , 
     &        l1 , N , n1 , n2 , n3
C
C     this routine evaluates modified spherical bessel functions.
C     vector version.
C
C     the arguments:
C       b...  bessel function at requested points.
C       z...  the points at which the function is to be evaluated.
C             assumed to be in ascending order.
C       l...  the l value of the function.
C       n...  the number of requested points.
C
C
C       for arguments (z.le.5.0)  use power series
C                                 15 terms good to 5.0d-14
C                     (z.gt.5.0)  use exponential representation.
C                     (z.gt.16.1) only first term in exponential
C                                 representation is required.
C
C     result has a factor of exp(-z) included to avoid overflow.
C
      common /dfac  / Dfac(23)
      common /fact  / Fact(13) , Fprod(7,7)
      dimension Z(*) , B(*) , den(15) , term(50) , zp(50) , denm(50,7) , 
     &          denp(50,7)
      dimension rp(50) , rm(50) , tzpi(50) , tzmi(50) , texm(50)
      equivalence (den(1),rp(1)) , (term(1),rm(1)) , (zp(1),tzpi(1))
      save zero , one , two , five , pt5 , f16pt1
      data zero/0.0D0/ , one/1.0D0/ , two/2.0D0/ , five/5.0D0/
      data pt5/0.5D0/ , f16pt1/16.1D0/
C
C     determine the number of points in each region.
      ilo1 = 0
      ilo2 = 0
      ilo3 = 0
      n1 = 0
      n2 = 0
      n3 = 0
      do 100 i = 1 , N
         if ( Z(i).lt.0 ) then
C     z.lt.zero
            B(i) = zero
         elseif ( Z(i).eq.0 ) then
            B(i) = zero
C     z.eq.zero
            if ( L.eq.zero ) B(i) = one
C     z.gt.zero
         elseif ( Z(i).le.five ) then
C     z.gt.zero.and.z.le.5.0
            if ( ilo1.eq.0 ) ilo1 = i
            n1 = n1 + 1
C     z.gt.5.0
         elseif ( Z(i).le.f16pt1 ) then
C     z.gt.5.0. and. z.le.16.1
            if ( ilo2.eq.0 ) ilo2 = i
            n2 = n2 + 1
         else
            if ( ilo3.eq.0 ) ilo3 = i
            n3 = n3 + 1
         endif
 100  continue
      ihi1 = ilo1 + n1 - 1
      ihi2 = ilo2 + n2 - 1
      ihi3 = ilo3 + n3 - 1
C
      if ( n1.ne.0 ) then
C     power series.
         do 150 i = ilo1 , ihi1
            zp(i) = Z(i)*Z(i)*pt5
            term(i) = (Z(i)**L)/Dfac(L+L+3)
            B(i) = term(i)
 150     continue
         do 200 j = 1 , 15
            den(j) = one/float(j*(L+L+j+j+1))
 200     continue
         do 250 j = 1 , 15
            do 220 i = ilo1 , ihi1
               term(i) = term(i)*zp(i)*den(j)
               B(i) = B(i) + term(i)
 220        continue
 250     continue
         do 300 i = ilo1 , ihi1
            B(i) = B(i)*exp(-Z(i))
 300     continue
      endif
C
C      exponential represention.
      if ( n2.ne.0 ) then
         l1 = L + 1
         do 350 i = ilo2 , ihi2
            rp(i) = Fprod(1,l1)
            rm(i) = Fprod(1,l1)
            tzi = two*Z(i)
            tzpi(i) = one/tzi
            tzmi(i) = -tzpi(i)
            texm(i) = exp(-tzi)
            denp(i,1) = one
            denm(i,1) = one
 350     continue
         if ( l1.gt.1 ) then
            do 380 k1 = 2 , l1
               do 360 i = ilo2 , ihi2
                  denp(i,k1) = denp(i,k1-1)*tzpi(i)
                  denm(i,k1) = denm(i,k1-1)*tzmi(i)
 360           continue
 380        continue
            do 400 k1 = 2 , l1
               do 390 i = ilo2 , ihi2
                  rp(i) = rp(i) + denp(i,k1)*Fprod(k1,l1)
                  rm(i) = rm(i) + denm(i,k1)*Fprod(k1,l1)
 390           continue
 400        continue
         endif
         do 450 i = ilo2 , ihi2
            B(i) = (rm(i)-((-one)**L)*rp(i)*texm(i))*tzpi(i)
 450     continue
      endif
C
C     only first term in exponential representation.
      if ( n3.ne.0 ) then
         l1 = L + 1
         do 500 i = ilo3 , ihi3
            rm(i) = Fprod(1,l1)
            tzmi(i) = -pt5/Z(i)
            denm(i,1) = one
 500     continue
         if ( l1.gt.1 ) then
            do 520 k1 = 2 , l1
               do 510 i = ilo3 , ihi3
                  denm(i,k1) = denm(i,k1-1)*tzmi(i)
 510           continue
 520        continue
            do 540 k1 = 2 , l1
               do 530 i = ilo3 , ihi3
                  rm(i) = rm(i) + denm(i,k1)*Fprod(k1,l1)
 530           continue
 540        continue
         endif
         do 550 i = ilo3 , ihi3
            B(i) = -rm(i)*tzmi(i)
 550     continue
      endif
C
C
      return
      end
@* INDEX.
