@* prsfwg.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[INPUT:] FWG                                                       
\item[OUTPUT:] IPOS                                                      
\item[OUTPUT:] ICHAR                                                     
\item[OUTPUT:] JCHAR                                                     
\item[OUTPUT:] NATSS                                                     
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]     NOTHING                                           
\item[Uses]  IOUT                                                   
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       DIGTST  IORD    NUMER                                  
\item[Called by]   NUMDOF                                                 
                                                                    
\end{description}
@a
      subroutine prsfwg(FWG,IPOS,ICHAR,JCHAR,NATSS)
      implicit none
      integer i , ICHAR , In , iord , Iout , IPOS , Ipunch , ival , 
     &        JCHAR , mult , NATSS , nprin , numer
      integer FWG(4)
      logical digit
      common /io    / In , Iout , Ipunch
C
C
C      parse framework group string one subspace at a time for function
C      numdof.
C      input:  fwg,   unpacked framework group string.  the first
C                     four characters should be the point group with
C                     character four used even for n<10.
C              ipos,  the current position in fwg.  this should either
C                     be zero (for the first call) or the first
C                     character of a subspace upon entry to prsfwg.
C                     upon exit it is set to the first character of the
C                     next subspace.
C      output: ichar: first character in symmetric subspace identifier
C                     ('o','c','s','x'), set to 'e' upon an error.
C              jchar: undefined for ichar = 'o' or 'e',
C                     order of subspace for ichar = 'c',
C                     order of point group for ichar = 'x',
C                     'h' for ichar = s in sigmah, etc.
C              natss: number of atoms in the subspace.
C
C
C
99001 format (1x,'PRSFWG-- UNABLE TO FIND LEFT SQUARE BRACKET')
99002 format (1x,'PRSFWG-- NON-DIGIT FOLLOWS "C" IN LINEAR SUBSPACE')
99003 format (1x,'PRSFWG-- UNRECOGINIZED SUBSPACE, ICHAR: "',a4,'"')
99004 format (1x,'PRSFWG-- UNRECOGNIZED POINT GROUP, ICHAR="X"')
99005 format (1x,'PRSFWG-- LEFT PARENTHESIS NOT FOUND')
99006 format (1x,'PRSFWG-- RIGHT PARENTHESIS NOT FOUND')
C
C
C                                       ipos=0 upon the initial entry.
      NATSS = 0
      if ( IPOS.eq.0 ) then
         do 50 i = 1 , 100
            if ( FWG(i).eq.iord('<') ) then
               IPOS = i + 1
               goto 100
            endif
C
 50      continue
         write (Iout,99001)
         ICHAR = iord('E')
         return
      endif
C                                       ipos is positioned at start of
C                                       a subspace.  check for a digit.
 100  mult = 1
      call digtst(FWG,IPOS,digit,ival)
      if ( digit ) mult = ival
      ICHAR = FWG(IPOS)
      IPOS = IPOS + 1
C                                       determine jchar.
      if ( ICHAR.ne.iord('>') ) then
         if ( ICHAR.ne.iord('O') ) then
            if ( ICHAR.eq.iord('C') ) then
               call digtst(FWG,IPOS,digit,ival)
               if ( .not.digit .and. FWG(IPOS).ne.iord('*') ) then
C
                  ICHAR = iord('E')
                  write (Iout,99002)
                  return
               else
                  JCHAR = ival
               endif
C
            elseif ( ICHAR.eq.iord('S') ) then
               JCHAR = FWG(IPOS+1)
               IPOS = IPOS + 1
               if ( JCHAR.eq.iord('(') ) then
                  JCHAR = iord(' ')
                  IPOS = IPOS - 1
               endif
C
            elseif ( ICHAR.ne.iord('X') ) then
C
               write (Iout,99003) ICHAR
               ICHAR = iord('E')
               return
            else
               nprin = numer(FWG)
               if ( FWG(1).eq.iord('C') ) then
                  JCHAR = 2*nprin
                  if ( FWG(4).eq.iord(' ') ) JCHAR = nprin
                  if ( nprin.eq.0 ) JCHAR = 2
C
               elseif ( FWG(1).eq.iord('D') ) then
                  JCHAR = 4*nprin
                  if ( FWG(4).eq.iord(' ') ) JCHAR = 2*nprin
C
               elseif ( FWG(1).eq.iord('S') ) then
                  JCHAR = nprin
C
               elseif ( FWG(1).eq.iord('T') ) then
                  JCHAR = 12
                  if ( FWG(2).eq.iord('D') ) JCHAR = 24
C
               elseif ( FWG(1).ne.iord('O') ) then
C
                  write (Iout,99004)
                  ICHAR = iord('E')
                  return
               else
                  JCHAR = 24
                  if ( FWG(2).eq.iord('H') ) JCHAR = 48
               endif
            endif
         endif
C                                         find left parenthesis.
 150     if ( IPOS.gt.100 ) then
            ICHAR = iord('E')
            write (Iout,99005)
            return
C
         elseif ( FWG(IPOS).eq.iord('(') ) then
C                                         sum atoms until right
C                                         parenthesis is encountered.
 160        IPOS = IPOS + 1
            if ( IPOS.gt.100 ) then
               ICHAR = iord('E')
               write (Iout,99006)
               return
C
            elseif ( FWG(IPOS).eq.iord(')') ) then
C                                         move ipos to the next subspace
               IPOS = IPOS + 1
               if ( FWG(IPOS).eq.iord(',') ) IPOS = IPOS + 1
            else
               call digtst(FWG,IPOS,digit,ival)
               if ( digit ) then
                  IPOS = IPOS - 1
                  NATSS = NATSS + ival*mult
               endif
               goto 160
            endif
         else
            IPOS = IPOS + 1
            goto 150
         endif
      endif
C                                         normal exit.
      return
C
      end
@* INDEX.
