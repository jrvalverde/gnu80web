@* estm.
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    FC                                                     
\item[Transmits as argument]  IANZ    LBL     NZ                                     
\item[Uses]  FC      IANZ    IC      IOUT    IZ      LALPHA  LBETA  
             LBL     NVAR    NZ      X                              
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       ICLEAR  ILSW    LNK1E   NREP    TREAD                  
\item[Called by]   STAR                                                   
                                                                    
\end{description}
@a
      subroutine estm
      implicit none
      double precision a1 , a2 , aa , aaa , Alpha , autoan , b1 , b2 , 
     &                 bbb , Beta , Bl , conbnd , constr , Convf , 
     &                 Dxmaxt , Eiglim , Eigmax , Eigmin , Energy , Es
      double precision F , Fc , Ff , Fmaxt , Fnccnv , Fncerr , Frcnst , 
     &                 Fs , Fswtch , Grderr , hartre , one , Rlim , 
     &                 Rmax , Rmin , X , xangst , Xname , Xx
      integer i , ia , Ianz , iatno , ib , Ic , ii , In , Iout , 
     &        iozmat , Ipunch , irow , isave , Istep , ivar , Iz , 
     &        jatno , jatom , Lalpha , Lbeta
      integer Lbl , Ndum , Ndum2 , Neg , Nmax , Np , nrep , nsave , 
     &        Nstep , Nvar , Nvarrd , Nz
      logical Prnt , Exit
      integer maxz
      dimension aa(3,3)
C this is a list of the row of the periodic table in which an atom belongs
C  data statement below assumes all beyond third row are same as third row
C the information is used to guess some diagonal derivatives
      dimension irow(86)
      dimension xangst(50) , isave(50)
      common /io    / In , Iout , Ipunch
      common /grdnt / Energy , F(50) , Frcnst(1275) , Nvar , Ndum
      common /optgrd/ X(100) , Xname(100) , Fc(2500) , Es , Fs(50) , 
     &                Xx(50,50) , Ff(50,50) , Convf , Fmaxt , Dxmaxt , 
     &                Rmax , Rmin , Rlim , Eigmax , Eigmin , Eiglim , 
     &                Fswtch , Fncerr , Grderr , Fnccnv , Ic(50) , 
     &                Nstep , Istep , Nmax , Np , Neg , Prnt , Exit , 
     &                Ndum2
      common /zmat  / Ianz(50) , Iz(50,4) , Bl(50) , Alpha(50) , 
     &                Beta(50) , Lbl(50) , Lalpha(50) , Lbeta(50) , Nz , 
     &                Nvarrd
C maximum atomic number
      data maxz/86/
      data a1 , a2/5.38D0 , 4.00D0/
      data aa/ - .129D0 , 0.186D0 , 0.349D0 , 0.186D0 , 0.574D0 , 
     &     0.805D0 , 0.349D0 , 0.805D0 , 1.094D0/
      data b1 , b2/1.35D0 , 1.0D0/
C this is a dummy from zn onwards
      data irow/2*1 , 8*2 , 8*3 , 68*3/
      data one/1.D0/
      data autoan/0.52917706D0/ , hartre/4.359814D0/
      data iozmat/507/
C
C
C     make guesses at the diagonal second derivatives.
C     bending force constants are either 1.35 for minimal basis, 1.00
C     otherwise.  for stretches the value chosen depends upon the
C     internuclear distance and the rows of the periodic table
C     in which the two affected atoms reside as well as the basis.
C     dummies are considered the same as hydrogens.
C
C
99001 format (1x,'ATOMIC NUMBER TOO LARGE IN SUBROUTINE ESTM')
C
C
      do 100 i = 1 , Nz
         if ( Ianz(i).gt.maxz ) then
            write (Iout,99001)
            call lnk1e
         endif
 100  continue
C
C                                             get z-matrix and allow for
C                                             changes in fc with basis.
      call tread(iozmat,Ianz,351,1,351,1,0)
      call ilsw(2,3,ia)
      aaa = a1
      if ( ia.ne.0 ) aaa = a2
      bbb = b1
      if ( ia.ne.0 ) bbb = b2
      if ( Nz.ge.2 ) then
C
C                                             convert bond lengths to
C                                             angstroms.
         do 150 i = 1 , Nvar
            xangst(i) = X(i)
            if ( nrep(i,Lbl,Nz).ne.0 ) xangst(i) = xangst(i)*autoan
 150     continue
C                                             guess diagonal second
C                                             derivatives in mdyne units
         do 200 i = 2 , Nz
            ivar = iabs(Lbl(i))
            if ( ivar.ne.0 ) then
               iatno = Ianz(i)
C here is where irow is used
               ia = irow(iatno)
               if ( iatno.lt.1 ) ia = 1
               jatom = Iz(i,1)
               jatno = Ianz(jatom)
               ib = irow(jatno)
               if ( jatno.lt.1 ) ib = 1
               ii = ivar + (ivar-1)*Nvar
               if ( Ic(ivar).eq.0 ) Fc(ii) = Fc(ii)
     &              + aaa/((xangst(ivar)-aa(ia,ib))**3)
            endif
 200     continue
         if ( Nz.ge.3 ) then
C
            do 220 i = 3 , Nz
               ivar = iabs(Lalpha(i))
               if ( ivar.ne.0 ) then
                  ii = ivar + (ivar-1)*Nvar
                  if ( Ic(ivar).eq.0 ) Fc(ii) = Fc(ii) + bbb
               endif
 220        continue
            if ( Nz.ge.4 ) then
C
               do 230 i = 4 , Nz
                  ivar = iabs(Lbeta(i))
                  if ( ivar.ne.0 ) then
                     ii = ivar + (ivar-1)*Nvar
                     if ( Ic(ivar).eq.0 ) Fc(ii) = Fc(ii) + bbb
                  endif
 230           continue
            endif
         endif
      endif
C
C                                              convert to atomic units
      constr = autoan**2/hartre
      conbnd = one/hartre
      call iclear(50,isave)
      nsave = 0
      do 300 i = 2 , Nz
         ivar = iabs(Lbl(i))
         if ( ivar.ne.0 .and. nrep(ivar,isave,nsave).eq.0 ) then
            nsave = nsave + 1
            isave(nsave) = ivar
            ii = ivar + (ivar-1)*Nvar
            if ( Ic(ivar).eq.0 ) Fc(ii) = Fc(ii)*constr
         endif
 300  continue
C
      call iclear(nsave,isave)
      nsave = 0
      do 400 i = 3 , Nz
         ivar = iabs(Lalpha(i))
         if ( ivar.ne.0 .and. nrep(ivar,isave,nsave).eq.0 ) then
            nsave = nsave + 1
            isave(nsave) = ivar
            ii = ivar + (ivar-1)*Nvar
            if ( Ic(ivar).eq.0 ) Fc(ii) = Fc(ii)*conbnd
         endif
 400  continue
C
      do 500 i = 4 , Nz
         ivar = iabs(Lbeta(i))
         if ( ivar.ne.0 .and. nrep(ivar,isave,nsave).eq.0 ) then
            nsave = nsave + 1
            isave(nsave) = ivar
            ii = ivar + (ivar-1)*Nvar
            if ( Ic(ivar).eq.0 ) Fc(ii) = Fc(ii)*conbnd
         endif
 500  continue
C
      return
C
      end
@* INDEX.
