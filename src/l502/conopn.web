@* conopn.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[PASSED:] N                                                         
\item[OUTPUT:] KEY                                                       
\item[OUTPUT:] ACURCY                                                    
\item[OUTPUT:] IFLAG                                                     
\item[INPUT:] IEXTP                                                     
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    A2      A3      ICOUNT                                 
\item[Transmits as argument]  A1      IRWC1   NTT2                                   
\item[Uses]  A1      A2      A3      CRIT    ICOUNT  IOUT    IRWC1  
             IRWC2   IRWC3   MAXNBF  NTT     NTT2    NTTMAX  PSAVE  
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       GABS    GFLOAT  GSQRT   TRAOPN  TREAD   TWRITE         
\item[Called by]   CYCOPN                                                 
                                                                    
\end{description}
@a
      subroutine conopn(N,KEY,ACURCY,IFLAG,IEXTP)
      implicit none
      double precision A1 , A2 , A3 , ACURCY , cosphi , cospsi , Crit , 
     &                 dp1 , dp2 , dp3 , Filabc , four , gabs , gfloat , 
     &                 gsqrt , one , onept9 , pt99 , pt995 , rmsdp
      double precision sp11 , sp12 , sp13 , sp22 , sp23 , sp33 , 
     &                 traopn , two , x , xxx , xy , y , yyy
      integer i , Icount , IEXTP , IFLAG , ifour , Ij , In , inone , 
     &        Iout , Ipunch , Irwc1 , Irwc2 , Irwc3 , Irwca , Irwcb , 
     &        Irweig , Irwfa , Irwfb , Irwgen , Irwh
      integer Irwibf , Irwpa , Irwpb , Irwps , Irwpt , Irws , Irwt , 
     &        Irwtm , Irwur , iskpd , ithree , itype , KEY , Lenibf , 
     &        loc1 , loc2 , Maxnbf , N , nq , Ntt
      integer Ntt2 , Nttmax
      integer Psave
      dimension ithree(2) , ifour(2) , itype(2) , iskpd(3)
      common /psave / Psave
      common /memry / A3(5700) , A2(5700) , A1(5700) , Filabc(32900)
      common /io    / In , Iout , Ipunch
      common /ind   / Ntt , Ij(127)
      common /max502/ Maxnbf , Nttmax
      common /icount/ Crit , Icount , Ntt2
      common /irw502/ Irwgen , Irweig , Irwca , Irwcb , Irwpa , Irwpb , 
     &                Irwpt , Irwps , Irwfa , Irwfb , Irwur , Irws , 
     &                Irwh , Irwt , Irwtm , Irwc1 , Irwc2 , Irwc3 , 
     &                Irwibf , Lenibf
      data pt99/0.99D0/ , pt995/0.995D0/ , one/1.0D0/ , onept9/1.9D0/
      data two/2.0D0/ , four/4.0D0/
      data inone/4H    / , ithree/4H3-PO , 4HINT./
      data ifour/4H4-PO , 4HINT./
C
C
C
C     open shell scf convergence routines
C     uses drum files 31 to 33 for scratch
C     each maximum of 4970 words long
C
C
C=ia  common/icount/icount,crit,ntt2
C
C
99001 format (' ',30x,d11.4)
99002 format (' ',48x,2A4)
C
      itype(1) = inone
      itype(2) = inone
      KEY = 1
      nq = Maxnbf*Maxnbf + Maxnbf
      IFLAG = 0
      Icount = Icount + 1
      loc1 = Irwc3
      if ( Icount.ne.(Icount/2)*2 ) loc1 = Irwc2
      loc2 = (Irwc2+Irwc3) - loc1
C     compress alpha and beta density matrices into one array
      do 100 i = 1 , Ntt
         A3(Ntt+i) = A3(Nttmax+i)
 100  continue
C     skip to end in first cycle or immediately after extrapolation
      if ( Icount.ne.1 ) then
C     p(n) now in a3.  read p(n-1) into a1
         call tread(Irwc1,A1,nq,1,Ntt2,1,0)
C     form p(n)-p(n-1) in a2
         do 150 i = 1 , Ntt2
            A2(i) = A3(i) - A1(i)
 150     continue
C     find length dp1
         sp11 = traopn(A2,A2,N)
         dp1 = gsqrt(sp11/two)
C     test for convergence by finding if root mean square dp is less
C     than acurcy
         rmsdp = dp1/gfloat(N)
         ACURCY = rmsdp
         if ( rmsdp.lt.Crit ) then
C     convergence criterion met ... exit
            KEY = 0
         else
C
            if ( Icount.ne.2 ) then
C
               if ( Icount.ge.4 ) then
                  call tread(loc1,A1,nq,1,Ntt2,1,0)
                  sp23 = sp12
                  sp33 = sp22
                  sp13 = traopn(A1,A2,N)
C     find length dp3
                  dp3 = gsqrt(sp33/two)
               endif
C     read p(n-1)-p(n-2) into a1
               call tread(loc2,A1,nq,1,Ntt2,1,0)
               sp12 = traopn(A1,A2,N)
               sp22 = traopn(A1,A1,N)
C     find length dp2
               dp2 = gsqrt(sp22/two)
C     find cosine of angle between successive displacements
               cosphi = sp12/(two*dp1*dp2)
               if ( Icount.ne.3 ) then
C     find cosine of angle between dp3 and plane of dp1 and dp2
                  x = (sp13*sp22-sp12*sp23)/(sp11*sp22-sp12*sp12)
                  y = (sp23*sp11-sp12*sp13)/(sp11*sp22-sp12*sp12)
                  cospsi = gsqrt((x*x*sp11+y*y*sp22+two*x*y*sp12)/two)
     &                     /dp3
                  if ( Psave.eq.0 ) write (Iout,99001) rmsdp
C     do not extrapolate unless 4 consecutive points are nearly coplanar
                  if ( IEXTP.lt.2 ) then
                     if ( cospsi.gt.pt99 ) then
C     express vector dp1 as x*dp3(projected)+y*dp2
                        y = -y/x
                        x = one/x
C     test if 2*2 matrix has real eigenvalues between -.95 and+.95
                        xy = y*y + four*x
                        if ( xy.ge.0 ) then
                           xy = gabs(y) + gsqrt(xy)
                           if ( xy.le.onept9 ) then
C     if requested, bypass the four-point extrapolation.
                              if ( IEXTP.lt.2 ) then
                                 xxx = x/(one-x-y)
                                 yyy = (x+y)/(one-x-y)
                                 do 152 i = 1 , Ntt2
                                    A3(i) = A3(i) + xxx*A1(i)
     &                                 + yyy*A2(i)
 152                             continue
                                 itype(1) = ifour(1)
                                 itype(2) = ifour(2)
                                 IFLAG = 1
                                 Icount = 0
                              endif
                              goto 160
                           endif
                        endif
C     if requested, bypass the three-point extrapolation.
                        if ( IEXTP.lt.1 ) then
C     if 4-point extrapolation is not possible try 3-point
                           if ( gabs(cosphi).gt.pt995 ) then
                              x = dp1/(dp2*cosphi-dp1)
                              do 154 i = 1 , Ntt2
                                 A3(i) = A3(i) + x*A2(i)
 154                          continue
                              itype(1) = ithree(1)
                              itype(2) = ithree(2)
                              IFLAG = 1
                              Icount = 0
                           endif
                        endif
                     endif
                  endif
               else
                  if ( Psave.eq.0 ) write (Iout,99001) rmsdp
               endif
            else
               if ( Psave.eq.0 ) write (Iout,99001) rmsdp
            endif
 160        call twrite(loc1,A2,nq,1,Ntt2,1,0)
         endif
      endif
      call twrite(Irwc1,A3,nq,1,Ntt2,1,0)
C     separate alpha and beta density matrices
      do 200 i = 1 , Ntt
         A3(Nttmax+1+Ntt-i) = A3(Ntt2-i+1)
 200  continue
      if ( Psave.eq.0 ) write (Iout,99002) itype(1) , itype(2)
      return
C
      end
@* INDEX.
