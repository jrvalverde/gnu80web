@* trcl80.
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    CMO     DBASE   I       IBASE   IDUMP   IFIL    IIA    
             IJ      INTCNT  IPRINT  J       JA      K       L      
             NJ      NTX     S       SINDX   T       V       V1     
\item[Transmits as argument]  INFORB  IRWIBF  ISMODE  ISPECT  LENIBF  LNFORB  LSPECT 
             X                                                      
\item[Uses]  CMO     DBASD   I       IBASD   IBASE   ICON    IDUMP  
             IFIL    IJ      IN      INFORB  INTCNT  IOP     IOUT   
             IPRINT  IRESET  IRWIBF  ISMODE  ISPECT  ITOTAL  IUX    
             J       K       KNTT1   KNTT2   L       LENIBF  LNFORB 
             LSPECT  MAXWS   MINDX   MODE    MOREWS  NBASIS  NJ     
             NOA     NOA2    NOAVA   NRORB   NTX     NVA2    NWPI   
             P       Q       R       S       SINDX   T       V      
             V1      VALINT  X                                      
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       DEFBUC  FDUMP   FILEIO  GFLOAT  ILSW    IREAD   IWAIT  
             IWIND   LABSCF  LNK1E   TREAD   UNPCK4                 
\item[Called by]   TRCLOS                                                 
                                                                    
\end{description}
@a
      subroutine trcl80
      implicit none
      double precision a0 , Atmchg , C , Cmo , gfloat , S , T , tenp8 , 
     &                 V1 , Valint , X , zero
      integer I , ia , iadk , iads , Ian , ib , Ibasd , Ibase , Ibfpad , 
     &        ibprev , ibuck , ic , Icharg , Icon , icont , iconv , 
     &        Icount , id , Idummy , Idump
      integer Ieval , Ifil , iflag , iflst , Iia , Ij , imdv , IMEMLN , 
     &        In , indij , indkl , indmj , indmk , indml , indmoi , 
     &        indmoj , indmok , indx , Inforb , intape
      integer Intcnt , Ioab , Iop , iopcl , Iout , Iprint , Ipunch , 
     &        Iq , iqbufr , iqproc , Ireset , Irwibf , iscr , Ismode , 
     &        Ispect , Istat , Itotal , Iux , ix , J
      integer Ja , jc , jdif , jq , jump , K , kk , kl , Kntt1 , Kntt2 , 
     &        L , Last , leng , lengs , Lenibf , Limint , ll , Lnforb , 
     &        Loab , lq
      integer Lspect , m , m1 , MAXBAS , Maxbuc , Maxws , mdim , mdim1 , 
     &        mdv , mdv2 , MEMLEN , Mindx , Minws , mjen , mjst , mken , 
     &        mkhigh , mklow , mkst , mlen
      integer mlst , Mode , moi , moj , moja , mok , moklk , mol , 
     &        mola , Morews , mstart , Multip , MXBAS1 , Nae , Natoms , 
     &        nb1 , Nbasis , Nbe , nbkdat , nbuck
      integer ncount , Ne , nfile , nint , Nj , nmok , nnu , Noa , 
     &        Noa2 , Noa3 , Noaob , noap , Noava , Noavb , Nob , Nob2 , 
     &        Nob3 , Nobva , Nobvb , Novaa
      integer Novab , Novbb , npass , Nrorb , Nrpext , nspace , NSQMAX , 
     &        ntt , nttt , Ntx , nucore , nuen , nust , Nva , Nva2 , 
     &        Nva3 , Nvavb , Nvb , Nvb2 , Nvb3
      integer Nwiib , Nwpi
      parameter (MAXBAS=150,MEMLEN=50000,IMEMLN=(2*MEMLEN),
     &           MXBAS1=(MAXBAS+1),NSQMAX=(MAXBAS*MAXBAS))
      logical iopt , mokocc
      integer P , Q , R , Sindx
      integer Dbase , Dbasd , Dcount
      integer V
      integer Regws
      dimension X(4760) , ix(11264)
      dimension Iia(2)
      dimension lengs(18) , nbkdat(6)
      dimension V1(MEMLEN)
      common /iop   / Iop(50)
      common /mol   / Natoms , Icharg , Multip , Nae , Nbe , Ne , 
     &                Nbasis , Ian(101) , Atmchg(100) , C(300)
      common /orb   / Ispect , Lspect , Nrorb , Noa , Nva , Nob , Nvb , 
     &                Noaob , Noava , Noavb , Nobva , Nobvb , Nvavb , 
     &                Noa2 , Noa3 , Nob2 , Nob3 , Nva2 , Nva3 , Nvb2 , 
     &                Nvb3 , Novaa , Novab , Novbb , Maxbuc , Ieval , 
     &                Ioab , Loab
C  v is integer here
      common /memry / V(IMEMLN)
      common /st802 / S(NSQMAX) , T(MAXBAS) , Ij(MXBAS1) , Nj(MXBAS1)
      common /cmo802/ Cmo(NSQMAX)
      common /packed/ I , J , K , L , Valint , Ja
      common /comorb/ Inforb , Lnforb
      common /io    / In , Iout , Ipunch
      common /ibf   / Ismode , Mode , Istat , Last , Ntx , Iux(5) , 
     &                Icon , Nrpext , Kntt1 , Kntt2 , Ibase , Ibasd(2) , 
     &                Dbase , Dbasd(2) , Ireset(2) , Iq , Ifil , 
     &                Intcnt , Itotal , Limint , Nwpi , Nwiib , Ibfpad
      common /locibf/ Irwibf , Lenibf
      common /mem802/ Minws , Regws , Maxws , Morews
      common /dump  / Idump , Idummy
      common /print / Iprint
      equivalence (X(1),ix(1)) , (S(1),X(1))
      equivalence (P,I) , (Q,J) , (R,K) , (Sindx,L) , (Mindx,K)
      equivalence (Valint,Iia(1))
      equivalence (Icount,Kntt1) , (Dcount,Kntt2)
      equivalence (V(1),V1(1))
C      data mdim,mdv/80,47952/
      data nfile/0/
      data iscr/2001/
      data zero , tenp8/0.D0 , 1.D8/
      mdim = MAXBAS
      mdv = MEMLEN
C
C
C     ******************************************************************
C
C     transformation for nbasis.gt.36. for other comments
C     and the list of options see trclos.
C
C     note that the array v is integer type. some of the partially
C     transformed integrals are stored in this array as integers.
C     this would cause problems in computers with 24 bit integers.
C
C     june 78/krishnan.
C
C     ******************************************************************
C
C
C
C     note that the integral buffer is equivalenced to s.  this needs
C     to be considered when changing dimensions.
C
C
C     scratch bucket used in this routine.
C
99001 format (i6)
99002 format (1x,i7,10x,4I4,2x,d15.8)
99003 format (1x,i7,' A.O.-INTEGRALS PROCESSED')
99004 format (/' DIMENSION EXCEEDS LIMIT'/)
99005 format (' ',30x,i7,' M.O.-INTEGRALS CREATED')
99006 format (' RHF INTEGRAL TRANSFORMATION:')
99007 format (' PROCESSED THE INTEGRAL FILE ',i2,' TIMES FOR EACH MOI')
99008 format (/' (AB/CD) TRANSFORMED INTEGRALS ARE NOT AVAILABLE'/)
C
C     ******************************************************************
C
C     set the working set size.
      nspace = Maxws
      if ( Nbasis.gt.50 ) nspace = Morews
C
      iopcl = Iop(5) - 1
      nbuck = Iop(6) + 1
      icont = Iop(7)
      imdv = Iop(8)
      Iprint = Iop(33)
      Idump = Iop(34)
C
      iopt = .false.
      if ( Iprint.ge.2 ) iopt = .true.
C
C     skip this link if not real rhf
      if ( iopcl.lt.0 ) call ilsw(2,1,iopcl)
      if ( iopcl.ne.0 ) goto 1200
C
C     test convergence flag
      iconv = 0
      if ( icont.eq.0 ) call ilsw(2,5,iconv)
      if ( iconv.ne.0 ) call lnk1e
C
C     check dimension
      write (Iout,99006)
      if ( Nbasis.gt.mdim ) then
         write (Iout,99004)
         call lnk1e
      endif
C
      if ( imdv.ne.0 ) read (In,99001) mdv
      mdv2 = mdv/2
C
C     check nbuck.
C     0 ... buckets for mp2: (ia/jb).
C     1 ... buckets for stability: (ia/jb),(ij/ab).
C     2 ... buckets for cid or mp3: (ij/ab),(ia/jb),(ij/kl).
C     3 ... buckets for cisd: (ij/ab),(ia/jb),(ik/kl),(ij/ka).
C     4 ... same as cisd, but includes (ia/bc).
C     5 ... the complete set of transformed integrals. (not implemented)
      if ( nbuck.gt.5 ) write (Iout,99008)
      if ( nbuck.gt.5 ) call lnk1e
C
C     read in window information
      call tread(Inforb,Ispect,Lnforb,1,Lnforb,1,0)
C
C     read in the m.o. coefficients
      call tread(Ispect,Cmo,Lspect,1,Lspect,1,0)
C
      nint = 0
C
C     ntt is the number of elements in a symmetric matrix of dimension
C     nbasis.
C     nttt is the number of elements in the n**3 array.
      mdim1 = mdim + 1
      nb1 = Nbasis + 1
      ntt = (Nbasis*(Nbasis+1))/2
      nttt = Nbasis*ntt
      noap = Noa + 1
C
C     initialize common ibf.
      call tread(Irwibf,Ismode,Lenibf,1,Lenibf,1,0)
C     lengths of the buckets for the output transformed integrals.
      do 100 I = 1 , 18
         lengs(I) = 0
 100  continue
      lengs(1) = Noa2*Nva2
      lengs(4) = Noa2*(Noa2+1)/2
      lengs(5) = Noava*(Noava+1)/2
      lengs(11) = Noava*Noa2
      lengs(15) = Noava*Nva2
      if ( nbuck.eq.2 ) then
      elseif ( nbuck.eq.3 ) then
         goto 200
      elseif ( nbuck.eq.4 ) then
         lengs(15) = 0
         goto 300
      elseif ( nbuck.eq.5 ) then
         goto 300
      else
C
         lengs(1) = 0
      endif
      lengs(4) = 0
 200  lengs(11) = 0
      lengs(15) = 0
C
C     define buckets.
 300  do 400 I = 1 , 18
         if ( lengs(I).gt.0 ) call defbuc((I+50),lengs(I))
 400  continue
      call defbuc(iscr,nttt)
C
C     form index arrays ij and nj
C     ij contains the leading index for indexing into a symmetric array.
C     nj contains the leading index for indexing into the n**3 array.
      do 500 I = 1 , nb1
         Ij(I) = (I*(I-1))/2
         Nj(I) = ntt*(I-1)
 500  continue
C     calculate the no. of nu which can be held in core.
      nnu = mdv/ntt
      nmok = mdv2/ntt
      if ( nnu.le.0 ) call lnk1e
C
C     ******************************************************************
C.....loop over all occupied orbitals, moi
C     ******************************************************************
C
C     call setpn(noa)
C
      do 1100 moi = 1 , Noa
C
C     call decrpn
C
C     set flag
         iflag = 1
C
         mkst = moi
         if ( nbuck.eq.1 ) mkst = noap
C
         mken = Nrorb
         indmoi = (moi-1)*Nbasis
         indmok = (mkst-1)*Nbasis
         if ( mken.lt.mkst ) goto 1100
C
C     clear v
         nust = 0
         nuen = 0
         npass = 0
 550     nust = nuen + 1
         nuen = nust + nnu - 1
         nuen = min0(nuen,Nbasis)
         npass = npass + 1
         nucore = (nuen-nust+1)*ntt
         do 600 J = 1 , nucore
            V(J) = 0
 600     continue
C
C     mark the nu's which are not in core.
         do 650 J = 1 , nb1
            Nj(J) = -1
 650     continue
         do 700 J = nust , nuen
            Nj(J) = (J-nust)*ntt
 700     continue
C
C     multiply c by 10**8
         do 750 I = 1 , Lspect
            Cmo(I) = Cmo(I)*tenp8
 750     continue
C
         iqbufr = 1
         iqproc = 2
         Intcnt = 0
C     the following two statements start the a. o. integrals
C     from the second integral unit for disc systems.
         Ntx = 1
         intape = Iux(2)
         call iwind(intape)
         call iread(intape,iqbufr,X)
         Ifil = 1
 800     call iwait(intape)
         iqbufr = iabs(iqbufr-2) + 1
         iqproc = iabs(iqproc-2) + 1
         Ibase = Ibasd(iqproc)
         Dbase = Dbasd(iqproc)
         call labscf(ix(Ibase),iflst)
         if ( iflst.eq.0 ) then
            if ( Ifil.eq.(nfile+Ntx*Icon) ) then
               call iwind(intape)
               Ntx = Ntx + 1
               intape = Iux(Ntx+1)
               call iwind(intape)
            endif
            call iread(intape,iqbufr,X)
            Ifil = Ifil + 1
         endif
C
C
         if ( Mode.ne.1 ) call lnk1e
         if ( Kntt1.gt.0 ) then
            jq = Ireset(1) + Ibase
            lq = jq + (Kntt1-1)*Nwpi
C     start processing of labels and integrals.
            do 820 m = jq , lq , Nwpi
               Ja = ix(m)
               Iia(1) = ix(m+1)
               Iia(2) = ix(m+2)
               call unpck4
               indij = Ij(I) + J
               indkl = Ij(K) + L
               if ( Nj(J).ge.0 ) then
                  ia = Nj(J) + indkl
                  V(ia) = V(ia) + Cmo(I+indmoi)*Valint
               endif
               if ( Nj(I).ge.0 ) then
                  ib = Nj(I) + indkl
                  V(ib) = V(ib) + Cmo(J+indmoi)*Valint
               endif
               if ( Nj(L).ge.0 ) then
                  ic = Nj(L) + indij
                  V(ic) = V(ic) + Cmo(K+indmoi)*Valint
               endif
               if ( Nj(K).ge.0 ) then
                  id = Nj(K) + indij
                  V(id) = V(id) + Cmo(L+indmoi)*Valint
               endif
 820        continue
            Intcnt = Intcnt + Kntt1
         endif
C
         if ( Kntt2.gt.0 ) then
            lq = Ireset(2) + Ibase
            jq = lq - (Kntt2-1)*Nwpi
            do 840 m = jq , lq , Nwpi
               Ja = ix(m)
               Iia(1) = ix(m+1)
               Iia(2) = ix(m+2)
               call unpck4
               Sindx = Sindx + 1
               if ( Sindx.eq.1 ) goto 830
               if ( Sindx.eq.2 ) then
C
C     ******************************************************************
C     case 2:  (ab,bc) =>  pq,qr
C     ******************************************************************
                  indij = Ij(P) + Q
                  indkl = Ij(Q) + R
                  if ( Nj(Q).ge.0 ) then
                     ia = Nj(Q) + indkl
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                     id = Nj(Q) + indij
                     V(id) = V(id) + Cmo(R+indmoi)*Valint
                  endif
                  if ( Nj(P).ge.0 ) then
                     ib = Nj(P) + indkl
                     V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  endif
                  if ( Nj(R).ge.0 ) then
                     ic = Nj(R) + indij
                     V(ic) = V(ic) + Cmo(Q+indmoi)*Valint
                  endif
               elseif ( Sindx.eq.3 ) then
C
C     ******************************************************************
C     case 3:  (ac,bc) =>  pq,rq
C     ******************************************************************
                  indij = Ij(P) + Q
                  indkl = Ij(R) + Q
                  if ( Nj(Q).ge.0 ) then
                     ia = Nj(Q) + indkl
                     ic = Nj(Q) + indij
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                     V(ic) = V(ic) + Cmo(R+indmoi)*Valint
                  endif
                  if ( Nj(P).ge.0 ) then
                     ib = Nj(P) + indkl
                     V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  endif
                  if ( Nj(R).ge.0 ) then
                     id = Nj(R) + indij
                     V(id) = V(id) + Cmo(Q+indmoi)*Valint
                  endif
               elseif ( Sindx.eq.4 ) then
C
C     ******************************************************************
C     case 4: (ab,ab) =>  pq,pq
C     ******************************************************************
                  indij = Ij(P) + Q
                  if ( Nj(Q).ge.0 ) then
                     ia = Nj(Q) + indij
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                  endif
                  if ( Nj(P).ge.0 ) then
                     ib = Nj(P) + indij
                     V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  endif
               elseif ( Sindx.eq.5 ) then
C
C     ******************************************************************
C     case 5: (aa,bc) =>  pp,qr
C     ******************************************************************
                  if ( Nj(P).ge.0 ) then
                     ia = Nj(P) + Ij(Q) + R
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                  endif
                  if ( Nj(R).ge.0 ) then
                     ib = Nj(R) + Ij(P+1)
                     V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  endif
                  if ( Nj(Q).ge.0 ) then
                     ic = Nj(Q) + Ij(P+1)
                     V(ic) = V(ic) + Cmo(R+indmoi)*Valint
                  endif
               elseif ( Sindx.eq.6 ) then
C
C     ******************************************************************
C     case 6:  (ab,cc) =>  pq,rr
C     ******************************************************************
                  if ( Nj(Q).ge.0 ) then
                     ia = Nj(Q) + Ij(R+1)
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                  endif
                  if ( Nj(P).ge.0 ) then
                     ib = Nj(P) + Ij(R+1)
                     V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  endif
                  if ( Nj(R).ge.0 ) then
                     ic = Nj(R) + Ij(P) + Q
                     V(ic) = V(ic) + Cmo(R+indmoi)*Valint
                  endif
               elseif ( Sindx.eq.8 ) then
C
C     ******************************************************************
C     case 8:  (aa,aa) =>  pp,pp
C     ******************************************************************
                  if ( Nj(P).ge.0 ) then
                     ia = Nj(P) + Ij(P+1)
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                  endif
C
               elseif ( Mindx.eq.1 ) then
C
C     ******************************************************************
C     case 7, three sub-cases:
C     1 -- (ab,bb) =>  pq,qq
C     2 -- (aa,bb) =>  pp,qq
C     3 -- (aa,ab) =>  pp,pq
C     ******************************************************************
                  if ( Nj(Q).ge.0 ) then
                     ia = Nj(Q) + Ij(Q+1)
                     ic = Nj(Q) + Ij(P) + Q
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                     V(ic) = V(ic) + Cmo(Q+indmoi)*Valint
                  endif
                  if ( Nj(P).ge.0 ) then
                     ib = Nj(P) + Ij(Q+1)
                     V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  endif
               elseif ( Mindx.eq.2 ) then
C
                  if ( Nj(P).ge.0 ) then
                     ia = Nj(P) + Ij(Q+1)
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                  endif
                  if ( Nj(Q).ge.0 ) then
                     ib = Nj(Q) + Ij(P+1)
                     V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  endif
               elseif ( Mindx.eq.3 ) then
C
                  if ( Nj(P).ge.0 ) then
                     ia = Nj(P) + Ij(P) + Q
                     ic = Nj(P) + Ij(P+1)
                     V(ic) = V(ic) + Cmo(Q+indmoi)*Valint
                     V(ia) = V(ia) + Cmo(P+indmoi)*Valint
                  endif
                  if ( Nj(Q).ge.0 ) then
                     ib = Nj(Q) + Ij(P+1)
                     V(ib) = V(ib) + Cmo(P+indmoi)*Valint
                  endif
               else
                  goto 830
               endif
               goto 840
C
C     ******************************************************************
C     case 1:  (ab,ac) =>  pq,pr
C     ******************************************************************
 830           indij = Ij(P) + Q
               indkl = Ij(P) + R
               if ( Nj(Q).ge.0 ) then
                  ia = Nj(Q) + indkl
                  V(ia) = V(ia) + Cmo(P+indmoi)*Valint
               endif
               if ( Nj(P).ge.0 ) then
                  ib = Nj(P) + indkl
                  id = Nj(P) + indij
                  V(ib) = V(ib) + Cmo(Q+indmoi)*Valint
                  V(id) = V(id) + Cmo(R+indmoi)*Valint
               endif
               if ( Nj(R).ge.0 ) then
                  ic = Nj(R) + indij
                  V(ic) = V(ic) + Cmo(P+indmoi)*Valint
               endif
C
 840        continue
            Intcnt = Intcnt + Kntt2
         endif
         if ( iflst.le.0 ) goto 800
         call iwind(intape)
C
C     integral processing complete.  for moi=1, get and print
C     the total number of integrals treated.
C     for moi .gt. 1, check intc against the number processed for moi=1.
C     if the two numbers are not the same, abort.
         if ( moi.le.1 ) then
            if ( Iprint.gt.0 ) write (Iout,99003) Intcnt
         endif
         if ( Intcnt.ne.Itotal ) call lnk1e
C
C     divide c by 10**8
         do 850 I = 1 , Lspect
            Cmo(I) = Cmo(I)/tenp8
 850     continue
C
C     ******************************************************************
C     the second suffix, j, is transformed to mok for all k,l
C     ******************************************************************
C
         call fileio(2,-iscr,0,0,0)
         call fileio(1,-iscr,0,0,0)
         indmk = indmok
         do 900 mok = mkst , mken
            if ( iflag.eq.2 ) then
C
               leng = ntt
               call fileio(2,iscr,leng,S,0)
            else
C
               do 860 I = 1 , ntt
                  S(I) = zero
 860           continue
            endif
            do 880 kl = 1 , ntt
               a0 = zero
               jc = kl
               do 870 J = nust , nuen
                  a0 = a0 + Cmo(indmk+J)*gfloat(V(jc))
                  jc = jc + ntt
 870           continue
               S(kl) = S(kl) + a0
 880        continue
            leng = ntt
            call fileio(1,iscr,leng,S,0)
            indmk = indmk + Nbasis
 900     continue
         iflag = 2
         if ( nuen.lt.Nbasis ) goto 550
         if ( Iprint.gt.0 .and. moi.eq.1 ) write (Iout,99007) npass
C
C     ******************************************************************
C     transformation of third and fourth suffixes
C     ******************************************************************
C
         mola = 0
         iadk = 0
         mstart = 1
         mjst = moi
         indmok = Nbasis*(mkst-1)
         indmoj = Nbasis*(mjst-1)
C
         indx = 0
         ncount = 0
         call fileio(2,-iscr,0,0,0)
         mklow = mkst - 1
         mkhigh = mkst - 1
         do 1000 mok = mkst , mken
            if ( mok.lt.mklow .or. mok.gt.mkhigh ) then
               mklow = mkhigh + 1
               mkhigh = mklow + nmok - 1
               mkhigh = min0(mkhigh,mken)
               if ( ncount.ne.0 ) then
                  leng = mola
                  call fileio(1,(ibuck+50),leng,V1,0)
                  mola = 0
                  iadk = 0
               endif
               leng = (mkhigh-mklow+1)*ntt
               call fileio(2,iscr,leng,V1,0)
               ncount = 1
            endif
            if ( mok.gt.Noa ) then
C
               mokocc = .false.
               ibuck = 5
               mjen = Noa
               if ( nbuck.eq.5 ) mjen = Nrorb
               mlst = noap
               mlen = Nrorb
            else
               mokocc = .true.
               if ( nbuck.eq.2 ) mjst = noap
               if ( nbuck.gt.3 ) mjst = 1
               mjen = Nrorb
            endif
            jdif = mjen - mjst + 1
            indmoj = Nbasis*(mjst-1)
            if ( jdif.gt.0 ) then
C
C     ******************************************************************
C     k is transformed to moj for all moj,l and one mok,moi
C     ******************************************************************
C
               iads = 0
               do 920 L = 1 , Nbasis
C
C     all k in t for one moi, mok, l
                  do 905 K = 1 , Nbasis
                     ll = min0(K,L)
                     kk = max0(K,L)
                     moklk = Ij(kk) + ll + iadk
                     T(K) = V1(moklk)
 905              continue
                  indmj = indmoj
                  do 910 moj = mjst , mjen
                     iads = iads + 1
                     a0 = zero
                     do 906 K = 1 , Nbasis
                        a0 = a0 + Cmo(indmj+K)*T(K)
 906                 continue
                     S(iads) = a0/tenp8
                     indmj = indmj + Nbasis
 910              continue
 920           continue
C
               do 950 moj = mjst , mjen
                  moja = moj - mjst + 1
                  if ( mok.le.Noa .or. moj.le.Noa ) then
C
                     mlst = noap
                     if ( mok.le.Noa ) then
                        mlst = moj
                        if ( moj.gt.Noa ) then
C
                           ibuck = 1
                           mlen = Nrorb
                        else
                           if ( moi.gt.moj ) then
C
                              ibuck = 11
                              mlst = noap
                           else
                              ibuck = 4
                           endif
                           mlen = Noa
                           if ( nbuck.gt.3 ) mlen = Nrorb
                        endif
                     endif
                     if ( moj.eq.moi ) mlst = mok
                  else
                     mlst = moj
                     mlen = Nrorb
                     ibuck = 15
                  endif
                  indml = (mlst-1)*Nbasis
                  if ( mola.eq.0 ) ibprev = ibuck
                  if ( (ibprev.ne.ibuck) .and. (mola.ne.0) ) goto 930
                  goto 935
C
 925              ibuck = 11
                  mlst = noap
 930              leng = mola
                  call fileio(1,(ibprev+50),leng,V1,0)
                  ibprev = ibuck
                  mola = 0
C
C     ******************************************************************
C     l is transformed to mol for all mol and one moj,mok,moi
C     ******************************************************************
C
 935              do 940 mol = mlst , mlen
                     mola = mola + 1
                     m1 = moja
                     a0 = zero
                     do 936 L = 1 , Nbasis
                        a0 = a0 + Cmo(indml+L)*S(m1)
                        m1 = m1 + jdif
 936                 continue
                     indml = indml + Nbasis
                     nint = nint + 1
                     V1(mola) = a0
                     if ( iopt ) write (Iout,99002) ibuck , moi , mok , 
     &                                  moj , mol , a0
                     if ( (mok.le.Noa) .and. (moj.le.Noa) ) then
                        if ( (mol.eq.Noa) .and. (nbuck.gt.3) ) goto 925
                     endif
 940              continue
 950           continue
C.....
               mjst = moi
            endif
            iadk = iadk + ntt
 1000    continue
         leng = mola
         if ( leng.ne.0 ) call fileio(1,(ibuck+50),leng,V1,0)
C
 1100 continue
      write (Iout,99005) nint
C
C     ..............
 1200 if ( Idump.gt.1 ) call fdump
      jump = 0
C     ..............
C
      return
C
      end
@* INDEX.
