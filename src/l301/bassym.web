@* bassym.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[INPUT:] NATOMS                                                    
\item[INPUT:] IOP                                                       
\item[INPUT:] NBASIS                                                    
\item[INPUT:] NSHELL                                                    
\item[PASSED:] X                                                         
\item[PASSED:] Y                                                         
\item[PASSED:] Z                                                         
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]     NOTHING                                           
\item[Transmits as argument]  MAPPER  MAPROT  NROT                                   
\item[Uses]  IOUT    MAPPER  MAPROT  NROT                           
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       GETNGR  ILSW    SHLDAT  TREAD   TWRITE                 
\item[Called by]   GINPUT                                                 
                                                                    
\end{description}
@a
      subroutine bassym(NATOMS,IOP,NBASIS,NSHELL,X,Y,Z)
      implicit none
      integer i , iat , ibasis , igr , In , IOP , ioper , Iout , 
     &        Ipunch , ishl , isymm , ix , iy , iz , j , jat , jbasis , 
     &        jshl , jtrans , LENB
      integer limshl , lneq , loshl , Mapper , Maprot , MAXATM , 
     &        MAXBAS , MAXPRM , MAXS21 , MAXSH1 , MAXSHL , mout , 
     &        MOUTD , MPLUS1 , msymm , MSYMMD , myfshl , mynshl , 
     &        NATOMS , NBASIS
      integer neq , neqatm , neqbas , neqshl , ngr , nosym , Nrot , 
     &        NSHELL , nsymop , numgr
      double precision X , Y , Z
      parameter (MAXSHL=100,MAXPRM=(3*MAXSHL),MAXSH1=(MAXSHL+1),
     &           MAXS21=(2*MAXSHL+1),LENB=(15*MAXSHL+7*MAXSHL/2+1))
      parameter (MAXBAS=150,MAXATM=100,MOUTD=(8*MAXBAS+8*MAXSHL),
     &           MPLUS1=(8*MAXSHL+1),MSYMMD=(8*MAXATM+44))
C     moutd  and mplus1 are sillies to get the reading and
C            equivalencing of neqbas and neqshl right
C
      dimension IOP(*) , X(*) , Y(*) , Z(*)
      dimension myfshl(MAXSHL) , mynshl(MAXSHL) , ngr(20)
      dimension msymm(MSYMMD) , jtrans(3,8) , neqatm(MAXATM,8)
      dimension mout(MOUTD) , neqshl(MAXSHL,8) , neqbas(MAXBAS,8)
      common /io    / In , Iout , Ipunch
      common /maps  / Nrot , Maprot(MAXBAS) , Mapper(MAXATM)
      equivalence (msymm(1),nsymop)
      equivalence (msymm(2),jtrans(1,1))
      equivalence (msymm(26),neqatm(1,1))
      equivalence (mout(1),neqshl(1,1))
C this is parameter dependent
      equivalence (mout(MPLUS1),neqbas(1,1))
C      equivalence (mout(801),neqbas(1,1))
C lneq is half of the (integer) dimension of mout
C  and is parameter dependent
      data isymm/551/ , neq/565/ , lneq/1000/
C
C
C      form the arrays neqbas and neqshl which are used in the scf
C      and integral programs, respectively, in the use of symmetry.
C      these are permutation lists over basis functions and over
C      shells.  the basis function array consists of signed integers
C      indicating possible phase changes of, for example, p functions
C      upon symmetry operations.
C
C
C
C
C
C
C
99001 format (1H0,'UNRECOGNIZED SHELL GROUP',2I7)
99002 format (1H0,'*** SYMMETRY TURNED OFF IN LINK 301 BY BASSYM ***')
99003 format (1x,'NEQSHL:'/)
99004 format (1x,30I4)
99005 format (1x,'NEQBAS:'/)
C
C
C                               nosym is set to 1 if an error is
C                               detected.
C
      nosym = 0
C
C                               tread the symmetry info.
C
      call tread(isymm,msymm,422,1,422,1,0)
C
C                               shldat provides the number of the first
C                               shell on each atom and the number of
C                               shells per atom.
C
      call shldat(myfshl,mynshl,NSHELL,X,Y,Z)
C
C                               given these data we can do the mapping
C                               from equivalent atoms to equivalent
C                               shells.
C
      do 100 ioper = 1 , nsymop
         ishl = 0
         do 50 iat = 1 , NATOMS
            jat = neqatm(iat,ioper)
            loshl = myfshl(jat)
            limshl = loshl + mynshl(jat) - 1
            do 20 jshl = loshl , limshl
               ishl = ishl + 1
               neqshl(ishl,ioper) = jshl
 20         continue
 50      continue
 100  continue
C
C                               neqbas is a permutation list over basis
C                               functions.  it differs from neqatm and
C                               neqshl in that its elements are signed
C                               to indicate the change in sign the
C                               function undergoes for the particular
C                               symmetry operation.  this is possible
C                               due to the restriction to two fold
C                               operations.  the arrays in common /maps/
C                               which form the basis for this algorithm
C                               are explained in subrioutine bldmap.
C                               the order of functions is:
C
C                              s:      p:      d:      pure d:     f:
C                              s       x       xx      zz-rr       xxx
C                                      y       yy      xz          yyy
C                                      z       zz      yz          zzz
C                                              xy      xx-yy       xyy
C                                              xz      xy          xxy
C                                              yz                  xxz
C                                                                  xzz
C                                                                  yzz
C                                                                  yyz
C                                                                  xyz
C
      do 200 ioper = 1 , nsymop
         ibasis = 0
         ix = jtrans(1,ioper)
         iy = jtrans(2,ioper)
         iz = jtrans(3,ioper)
         do 150 iat = 1 , NATOMS
            jat = neqatm(iat,ioper)
            jbasis = Mapper(jat) - 1
C
C                                the functions are broken into groups
C                                (s,p,d,f).  ngr contains the groups
C                                for jat.  (for example, if jat were a
C                                carbon at 6-31g* ngr would contain
C                                1 1 3 1 3 6.)
C
            call getngr(ngr,numgr,Nrot,Mapper,Maprot,jat,NATOMS,NBASIS,
     &                  nosym)
            igr = 1
C
C                                 top of loop over groups.
C
 120        if ( ngr(igr).eq.1 ) then
C
C                                 s group.
C
               ibasis = ibasis + 1
               jbasis = jbasis + 1
               neqbas(ibasis,ioper) = jbasis
               igr = igr + 1
C
            elseif ( ngr(igr).eq.3 ) then
C
C                                 p group.
C
               neqbas(ibasis+1,ioper) = (jbasis+1)*ix
               neqbas(ibasis+2,ioper) = (jbasis+2)*iy
               neqbas(ibasis+3,ioper) = (jbasis+3)*iz
               ibasis = ibasis + 3
               jbasis = jbasis + 3
               igr = igr + 1
C
C
C                                d group.
C
            elseif ( ngr(igr).eq.6 ) then
               neqbas(ibasis+1,ioper) = jbasis + 1
               neqbas(ibasis+2,ioper) = jbasis + 2
               neqbas(ibasis+3,ioper) = jbasis + 3
               neqbas(ibasis+4,ioper) = (jbasis+4)*ix*iy
               neqbas(ibasis+5,ioper) = (jbasis+5)*ix*iz
               neqbas(ibasis+6,ioper) = (jbasis+6)*iy*iz
               ibasis = ibasis + 6
               jbasis = jbasis + 6
               igr = igr + 1
C
C
C                                f group.
C
            elseif ( ngr(igr).eq.7 ) then
               neqbas(ibasis+01,ioper) = (jbasis+01)*ix
               neqbas(ibasis+02,ioper) = (jbasis+02)*iy
               neqbas(ibasis+03,ioper) = (jbasis+03)*iz
               neqbas(ibasis+04,ioper) = (jbasis+04)*ix
               neqbas(ibasis+05,ioper) = (jbasis+05)*iy
               neqbas(ibasis+06,ioper) = (jbasis+06)*iz
               neqbas(ibasis+07,ioper) = (jbasis+07)*ix
               neqbas(ibasis+08,ioper) = (jbasis+08)*iy
               neqbas(ibasis+09,ioper) = (jbasis+09)*iz
               neqbas(ibasis+10,ioper) = (jbasis+10)*ix*iy*iz
               ibasis = ibasis + 10
               jbasis = jbasis + 10
               igr = igr + 1
C
C
C                               pure d group.
C
            elseif ( ngr(igr).ne.5 ) then
C
C
C                                unrecognized group.
C
               nosym = 1
               write (Iout,99001) igr , ngr(igr)
               igr = igr + 1
            else
               neqbas(ibasis+1,ioper) = jbasis + 1
               neqbas(ibasis+2,ioper) = (jbasis+2)*ix*iz
               neqbas(ibasis+3,ioper) = (jbasis+3)*iy*iz
               neqbas(ibasis+4,ioper) = jbasis + 4
               neqbas(ibasis+5,ioper) = (jbasis+5)*ix*iy
               ibasis = ibasis + 5
               jbasis = jbasis + 5
               igr = igr + 1
            endif
C
C                                process the next group, if any.
C
            if ( igr.le.numgr ) goto 120
 150     continue
 200  continue
C
C                                do debug printing if requested.
C
      if ( IOP(33).ne.0 ) then
         write (Iout,99003)
         do 250 i = 1 , NSHELL
            write (Iout,99004) (neqshl(i,j),j=1,nsymop)
 250     continue
         write (Iout,99005)
         do 300 i = 1 , NBASIS
            write (Iout,99004) (neqbas(i,j),j=1,nsymop)
 300     continue
      endif
C
C                                check the error flag and return.
C
      if ( nosym.ne.0 ) then
         call ilsw(1,26,2)
         write (Iout,99002)
         return
      endif
C
      call twrite(neq,mout,lneq,1,lneq,1,0)
      return
C
      end
@* INDEX.
