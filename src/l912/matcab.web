@* matcab.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[INPUT:] NIJ                                                       
\item[INPUT:] NKL                                                       
\item[INPUT:] NMN                                                       
\item[PASSED:] IBUC1                                                     
\item[PASSED:] IBUC2                                                     
\item[PASSED:] IBUC3                                                     
\item[INPUT:] ISIGN                                                     
\item[INPUT:] IOPT                                                      
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    V                                                      
\item[Uses]  MDV     V       ZERO                                   
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       FILEIO  LNK1E   TRACK                                  
\item[Called by]   CIDENS  DD3                                            
                                                                    
\end{description}
@a
      subroutine matcab(NIJ,NKL,NMN,IBUC1,IBUC2,IBUC3,ISIGN,IOPT)
      implicit none
      double precision F42 , Four , Half , One , Onept5 , Ten , Three , 
     &                 thresh , Two , V , Zero
      integer i , IBUC1 , IBUC2 , IBUC3 , ibucfl , ij , ijbloc , 
     &        ijleft , ijmax , ind1 , ind2 , ind3 , IOPT , ISIGN , iv1 , 
     &        iv2 , iv21 , iv3 , iv31 , kl
      integer klbloc , klleft , klmax , leng , max1 , max2 , max3 , 
     &        Mdv , mdv3 , mdvlft , mn , nfull , nfull1 , nfull2 , 
     &        nfull3 , NIJ , nijkl , nijmn , NKL , nklmn
      integer NMN , nsum
      common /v     / V(20000) , Mdv
      common /const / Zero , Half , One , Onept5 , Two , Three , Four , 
     &                Ten , F42
      data thresh/1.D-8/
C
C***********************************************************************
C1matcab
C
C     accepts nij*nkl matrix a from ibuc1
C     accepts nij*nmn matrix b from ibuc2
C     forms   nkl*nmn matrix c in ibuc3
C          c(kl,mn) = sum (ij) a(ij,kl)*b(ij,mn)
C          note that this means ij is the slower running subscript in
C          both a and b.
C
C     isign ... .gt.0: sums positive
C               .lt.0: sums negative
C
C     iopt ... 0: c is initialized
C              1: c is added to the previously calculated c
C
C     this routine checks for zeroes in ibuc1.
C
C     sept,77  krishnan
C
C***********************************************************************
C
C
C
      call track('MATCAB')
C
      if ( NIJ*NKL*NMN.le.0 ) return
C
      mdv3 = Mdv/3
      ibucfl = 0
      nijkl = NIJ*NKL
      nijmn = NIJ*NMN
      nklmn = NKL*NMN
      nsum = nijkl + nijmn + nklmn
      mdvlft = Mdv
      max3 = float(nklmn)*float(Mdv)/float(nsum)
      if ( max3.lt.NMN ) max3 = NMN
      if ( nklmn.le.mdv3 ) max3 = nklmn
      mdvlft = mdvlft - max3
      nsum = nsum - nklmn
      max1 = float(nijkl)*float(mdvlft)/float(nsum)
      if ( max1.lt.NKL ) max1 = NKL
      max2 = Mdv - max1 - max3
      if ( max2.lt.NMN ) then
         max2 = NMN
         max3 = Mdv - max1 - max2
         if ( max3.lt.NMN ) then
            max3 = NMN
            max1 = Mdv - max2 - max3
            if ( max1.lt.NKL ) call lnk1e
         endif
      endif
      if ( max3.ge.nklmn ) ibucfl = 1
C
      iv1 = 0
      iv2 = max1
      iv3 = max1 + max2
      iv21 = iv2 + 1
      iv31 = iv3 + 1
      nfull1 = max1/NKL
      nfull2 = max2/NMN
      nfull3 = max3/NMN
      nfull = min0(nfull1,nfull2)
C
C     read from ibuc1 and ibuc2
      call fileio(2,-IBUC1,0,0,0)
      call fileio(2,-IBUC2,0,0,0)
      ijleft = NIJ
      ijmax = 0
 100  ijbloc = min0(ijleft,nfull)
      ijleft = ijleft - ijbloc
      leng = ijbloc*NKL
      call fileio(2,IBUC1,leng,V,0)
      leng = ijbloc*NMN
      call fileio(2,IBUC2,leng,V(iv21),0)
C
C     read and increment ibuc3
      call fileio(2,-IBUC3,0,0,0)
      call fileio(1,-IBUC3,0,0,0)
      klleft = NKL
      klmax = 0
 200  klbloc = min0(klleft,nfull3)
      klleft = klleft - klbloc
      leng = klbloc*NMN
      if ( ijmax.le.0 .and. IOPT.eq.0 ) then
         do 250 i = 1 , leng
            V(iv3+i) = Zero
 250     continue
C
      elseif ( ibucfl.le.0 .or. ijmax.le.0 ) then
         call fileio(2,IBUC3,leng,V(iv31),0)
      endif
C
C     form product in v3
      ind3 = iv3
      if ( ISIGN.lt.0 ) then
C
         do 300 kl = 1 , klbloc
            ind2 = iv2
            ind1 = klmax + kl
            do 260 ij = 1 , ijbloc
               if ( dabs(V(ind1)).gt.thresh ) then
                  do 255 mn = 1 , NMN
                     V(ind3+mn) = V(ind3+mn) - V(ind1)*V(ind2+mn)
 255              continue
               endif
               ind1 = ind1 + NKL
               ind2 = ind2 + NMN
 260        continue
            ind3 = ind3 + NMN
 300     continue
      else
         do 350 kl = 1 , klbloc
            ind2 = iv2
            ind1 = klmax + kl
            do 320 ij = 1 , ijbloc
               if ( dabs(V(ind1)).gt.thresh ) then
                  do 305 mn = 1 , NMN
                     V(ind3+mn) = V(ind3+mn) + V(ind1)*V(ind2+mn)
 305              continue
               endif
               ind1 = ind1 + NKL
               ind2 = ind2 + NMN
 320        continue
            ind3 = ind3 + NMN
 350     continue
      endif
C
C     write on ibuc3
      call fileio(1,IBUC3,leng,V(iv31),0)
      klmax = klmax + klbloc
      if ( klleft.gt.0 ) goto 200
      ijmax = ijmax + ijbloc
      if ( ijleft.gt.0 ) goto 100
      return
C
      end
@* INDEX.
