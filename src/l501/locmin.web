@* locmin.
\section*{\sf Dummy Arguments}  \begin{description}
                                                                    
\item[INPUT:] LM                                                        
\item[INPUT:] LN                                                        
\item[INPUT:] X                                                         
\item[OUTPUT:] Y                                                         
\item[INPUT:] XL                                                        
\item[OUTPUT:] NOMIN                                                     
\item[OUTPUT:] XLAM                                                      
\item[OUTPUT:] YMIN                                                      
\item[INPUT:] IPRINT                                                    
\item[INPUT:] MDM                                                       
                                                                    
\end{description} \section*{\sf Common Variables}  \begin{description}
                                                                    
\item[Modifies]    BS                                                     
\item[Transmits as argument]  B                                                      
\item[Uses]  B       IOUT    ONE     ZERO                           
                                                                    
\end{description}  \section*{\sf External Subprograms}  \begin{description}
                                                                    
\item[Calls]       GABS    GFLOAT  INV     ROOTN                          
\item[Called by]   FIRST                                                  
                                                                    
\end{description}
@a
      subroutine locmin(LM,LN,X,Y,XL,NOMIN,XLAM,YMIN,IPRINT,MDM)
      implicit none
      double precision A , a0 , a1 , a2 , a3 , an , B , Big , di , f1 , 
     &                 f2 , Fillab , Four , gabs , gfloat , One , 
     &                 Onept5 , Pt5 , rootac , Small
      double precision tau , Three , Two , X , x0 , xi , XL , XLAM , 
     &                 xlimit , xst , Y , YMIN , Zero
      integer i , i1 , i2 , i3 , ierr , In , Iout , IPRINT , Ipunch , 
     &        j , k , LM , LN , m2 , m21 , m22 , m3 , m6 , MDM , mdm1
      integer mpts
      logical NOMIN
      real Bs(1)
      dimension X(MDM,MDM) , Y(MDM) , XL(MDM)
      dimension f1(10) , f2(10) , an(10)
      common /const / Zero , Pt5 , One , Onept5 , Two , Three , Four , 
     &                Big , Small
      common /memry / A(4970) , B(4970) , Fillab(40060)
C      common /ab/a(4970),b(4970),fillab(20060)
      common /io    / In , Iout , Ipunch
      equivalence (Bs(1),B(1))
      data rootac/1.D-9/
      data mpts/201/
C     ******************************************************************
C     locmin finds the smallest local minimum of a polynomial given
C     by its corresponding set of linear equations
C
C     lm     : degree of the polynomial
C     ln     : number of points
C     x      : matrix  defining the polymomial
C     y      : column vector associated with x
C     xl     : abscissa associated with y
C     nomin  : logical variable: true if no local minimum found
C     xlam   : abscissa of lowest local minimum
C     ymin   : ordinate of it
C     iprint : print option
C     mdm    : max dimension of x and y
C
C     coded in april 75 by rs9b
C     ******************************************************************
C
C
C
C
99001 format ('1VALUES FOR THE POLYNOMIAL'/1x,25(1H*)//7x,'X',26x,
     &        4HF(X),20x,5HF'(X),18x,6HF''(X)/)
99002 format (f10.4,10x,3D25.12)
99003 format (/)
99004 format (' NO MINIMUM FOUND')
C     ******************************************************************
      mdm1 = MDM + 1
      m2 = LM + 1
      m3 = 3*mpts
      m6 = m3 + 1
C
C     invert x
      call inv(X,m2,f1,f2,an,B,MDM)
      if ( m2.ne.0 ) then
C
C     compute the coefficients of the polynomial and its first and
C     second derivatives
         do 50 i = 1 , m2
            a0 = Zero
            do 20 j = 1 , m2
               a0 = a0 + X(i,j)*Y(j)
 20         continue
            an(i) = a0
 50      continue
C
         do 100 i = 2 , m2
            i1 = i - 1
            f1(i1) = an(i)*gfloat(i1)
 100     continue
C
         do 150 i = 3 , m2
            i1 = i - 1
            i2 = i - 2
            f2(i2) = f1(i1)*gfloat(i2)
 150     continue
C
C     find all real roots of the first derivative within the interval
C     (xl(1),xl(ln))
C     get the value of the second derivative at each local extremum,
C     and collect all minima in y
         xlimit = XL(LN)
         xst = XL(1)
         tau = XL(2) - XL(1)
         i3 = 0
         NOMIN = .true.
         do 200 i = 1 , LN
            x0 = XL(i)
            call rootn(ierr,a1,x0,f1,i2)
            if ( ierr.eq.0 ) then
               if ( .not.(tau.gt.Zero .and. (a1.gt.xlimit .or. a1.lt.xst
     &              )) ) then
                  if ( .not.(tau.lt.Zero .and. (a1.lt.xlimit .or. a1.gt.
     &                 xst)) ) then
                     a0 = One
                     a2 = Zero
                     do 152 j = 1 , i2
                        a2 = a2 + f2(j)*a0
                        a0 = a0*a1
 152                 continue
                     if ( a2.ge.Zero ) then
                        if ( i3.ne.0 ) then
                           do 154 k = 1 , i3
                              if ( gabs(a1-Y(k)).le.rootac ) goto 200
 154                       continue
                        endif
                        i3 = i3 + 1
                        Y(i3) = a1
                        NOMIN = .false.
                     endif
                  endif
               endif
            endif
 200     continue
C
C     output of mpts points of the polynomial and its first and
C     second derivatives
         if ( .not.(IPRINT.le.0 .or. (IPRINT.le.2 .and. i3.eq.1)) ) then
            write (Iout,99001)
            m21 = m2 - 1
            m22 = m2 - 2
            xi = xst
            di = (xlimit-xst)/gfloat(mpts-1)
            do 240 i = 1 , mpts
               a0 = One
               a1 = Zero
               do 210 j = 1 , m2
                  a1 = a1 + an(j)*a0
                  a0 = a0*xi
 210           continue
               a0 = One
               a2 = Zero
               do 220 j = 1 , m21
                  a2 = a2 + f1(j)*a0
                  a0 = a0*xi
 220           continue
               a0 = One
               a3 = Zero
               do 230 j = 1 , m22
                  a3 = a3 + f2(j)*a0
                  a0 = a0*xi
 230           continue
               if ( mod(i-1,10).eq.0 ) write (Iout,99002) xi , a1 , a2 , 
     &              a3
               Bs(i) = sngl(xi)
               Bs(i+mpts) = sngl(xi)
               Bs(i+2*mpts) = sngl(xi)
               Bs(i+3*mpts) = sngl(a1)
               Bs(i+4*mpts) = sngl(a2)
               Bs(i+5*mpts) = sngl(a3)
               xi = xi + di
 240        continue
C      call plot2(mpts,bs,b(m6),m3,lm-2)
            write (Iout,99003)
         endif
         if ( .not.NOMIN ) goto 300
      endif
      XLAM = XL(LN)
      YMIN = Y(LN)
      write (Iout,99004)
      NOMIN = .true.
      return
C
C     find the smallest minimum
 300  YMIN = Zero
      do 400 i = 1 , i3
         a0 = Zero
         a1 = One
         xi = Y(i)
         do 350 j = 1 , m2
            a0 = a0 + a1*an(j)
            a1 = a1*xi
 350     continue
         if ( a0.lt.YMIN ) then
            YMIN = a0
            XLAM = Y(i)
         endif
 400  continue
      return
C
      end
@* INDEX.
