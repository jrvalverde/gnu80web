@*nbodim.
\section*{\sf Dummy Arguments}  \begin{description}

\item[INPUT:] MEMORY

\end{description} \section*{\sf Common Variables}  \begin{description}

\item[Modifies]    IMVAL   LL      LU      LVAL    MXAO    MXAOLM  MXBO
             NORBS
\item[Transmits as argument]  IWTNAB  IWTNAO
\item[Uses]  IPRINT  IW3C    IWTNAB  IWTNAO  JPRINT  LANG    LCTR
             LFNPR   LL      LU      LVAL    MXAO    MXAOLM  MXBO
             NATOMS  NBAS    NDIM    ORTHO

\end{description}  \section*{\sf External Subprograms}  \begin{description}

\item[Calls]       IOINQR
\item[Called by]   NBO

\end{description}
@a
      subroutine nbodim(MEMORY)
C*****************************************************************************
      implicit none
      integer i , Iatcr , Iatno , Ichoos , il , im , Imval , Ino , io ,
     &        ioinqr , Iprint , Ipseud , iread , Ispin , ityp , Iw3c ,
     &        Iwapol , Iwcubf , Iwdetl , Iwdm
      integer Iwfock , Iwhybs , Iwmulp , Iwpnao , Iwtnab , Iwtnao ,
     &        Iwtnbo , Iznuc , j , Jcore , Jprint , Kopt , l , Label ,
     &        Lang , Larc , Lbl , Lctr , Lfnao , Lfnarc
      integer Lfndaf , Lfndef , Lfndm , Lfnin , Lfnmo , Lfnnab ,
     &        Lfnnao , Lfnnbo , Lfnnho , Lfnnlm , Lfnpna , Lfnpnb ,
     &        Lfnpnh , Lfnpnl , Lfnppa , Lfnpr , Ll , llu , lm , Lorb
      integer Lorbc , Lstemt , Lstocc , Lu , Lval , MAXATM , MAXBAS ,
     &        MEMORY , Munit , Mxao , mxao2 , mxao3 , Mxaolm , Mxbo ,
     &        n , Natoms , Nbas , Ndim , need , need0
      integer need1 , need2 , need3 , Norbs , nspdfg
      logical Rohf , Uhf , Ci , Open , Complx , Alpha , Beta , Mcscf ,
     &        Auhf , Ortho
      dimension nspdfg(5,2)
C
      parameter (MAXATM=99,MAXBAS=500)
      common /nbflag/ Rohf , Uhf , Ci , Open , Complx , Alpha , Beta ,
     &                Mcscf , Auhf , Ortho
      common /nbinfo/ Ispin , Natoms , Ndim , Nbas , Mxbo , Mxao ,
     &                Mxaolm , Munit
      common /nbopt / Iwdm , Iw3c , Iwapol , Iwhybs , Iwpnao , Iwtnao ,
     &                Iwtnab , Iwtnbo , Iwfock , Iwcubf , Ipseud ,
     &                Kopt , Iprint , Iwdetl , Iwmulp , Ichoos , Jcore ,
     &                Jprint(60)
      common /nbio  / Lfnin , Lfnpr , Lfnao , Lfnpna , Lfnnao , Lfnpnh ,
     &                Lfnnho , Lfnpnb , Lfnnbo , Lfnpnl , Lfnnlm ,
     &                Lfnmo , Lfndm , Lfnnab , Lfnppa , Lfnarc ,
     &                Lfndaf , Lfndef
      common /nbbas / Label(MAXBAS,6) , Lval(MAXBAS) , Imval(MAXBAS) ,
     &                Lstocc(MAXBAS) , Lstemt(MAXBAS) , Larc(MAXBAS) ,
     &                Lbl(MAXBAS) , Lorbc(MAXBAS) , Lorb(MAXBAS)
      common /nbatom/ Iatno(MAXATM) , Ino(MAXATM) , Norbs(MAXATM) ,
     &                Ll(MAXATM) , Lu(MAXATM) , Iznuc(MAXATM) ,
     &                Iatcr(MAXATM)
      common /nbao  / Lctr(MAXBAS) , Lang(MAXBAS)
C
      data iread/4HREAD/
C
C  nbodim:  set up dimensioning information, lists in common/nbatom/,
C           and compare storage needs with amount of storage available
C
C  find:
C     mxaolm, the maximum number of atomic orbitals of the same symmetry
C              on a single atom
C     mxao, the maximum number of atomic orbitals per atom
C     mxbo, the maximum number of atomic orbitals per two-center or
C              three-center bond
C
      do 100 i = 1 , Nbas
         lm = Lang(i)
         Lval(i) = lm/100
         im = lm - Lval(i)*100
         if ( im.gt.50 ) im = im - 50
         Imval(i) = im
 100  continue
C
      Mxao = 0
      mxao2 = 0
      mxao3 = 0
      Mxaolm = 0
      llu = 0
      do 300 i = 1 , Natoms
         n = 0
         do 150 il = 1 , 5
            do 120 ityp = 1 , 2
               nspdfg(il,ityp) = 0
 120        continue
 150     continue
         do 200 j = 1 , Nbas
            if ( Lctr(j).eq.i ) then
               lm = Lang(j)
               l = lm/100
               im = lm - l*100
C
C  if im.ne.1 (that is, if this is not the first component of the
C  ang. mom. l functions on the atom), don't count it in nspdfg:
C
               if ( im.eq.1 ) then
C
C  ityp=1 for cartesian function, =2 for true spherical harmonic:
C
                  ityp = 1
                  if ( im.gt.50 ) ityp = 2
                  il = l + 1
                  nspdfg(il,ityp) = nspdfg(il,ityp) + 1
               endif
            endif
            if ( Lctr(j).eq.i ) n = n + 1
 200     continue
C
C  number of s orbitals= no. s orbs input + no. cartesian d and g orbs:
C
         nspdfg(1,1) = nspdfg(1,1) + nspdfg(1,2) + nspdfg(3,1)
     &                 + nspdfg(5,1)
C
C  number of p orbitals= no. p orbs input + no. cartesian f orbs:
C
         nspdfg(2,1) = nspdfg(2,1) + nspdfg(2,2) + nspdfg(4,1)
C
C  number of d orbitals= no. d orbs input + no. cartesian g orbs:
C
         nspdfg(3,1) = nspdfg(3,1) + nspdfg(3,2) + nspdfg(5,1)
C
C  number of f orbitals:
C
         nspdfg(4,1) = nspdfg(4,1) + nspdfg(4,2)
C
C  number of g orbitals:
C
         nspdfg(5,1) = nspdfg(5,1) + nspdfg(5,2)
C
         do 250 il = 1 , 5
            if ( nspdfg(il,1).gt.Mxaolm ) Mxaolm = nspdfg(il,1)
 250     continue
C
         Norbs(i) = n
         Ll(i) = llu + 1
         Lu(i) = Ll(i) + n - 1
         llu = Lu(i)
         if ( n.gt.Mxao ) then
            mxao3 = mxao2
            mxao2 = Mxao
            Mxao = n
         elseif ( n.gt.mxao2 ) then
            mxao3 = mxao2
            mxao2 = n
         elseif ( n.gt.mxao3 ) then
            mxao3 = n
         endif
 300  continue
      Mxbo = Mxao + mxao2
      if ( Iw3c.eq.1 ) Mxbo = Mxbo + mxao3
C
C  compute storage requirements and compare with available core space:
C
C  storage for density matrix (dm) and transformations (t):
C
      need0 = 2*Ndim*Ndim
C
C  compute storage for natural population analysis:
C
      need1 = 0
      io = ioinqr(Iwtnao)
      if ( io.ne.iread .and. .not.Ortho ) then
         need = Ndim + Ndim + Ndim*Ndim + Mxaolm*Mxaolm + Ndim +
     &          Mxaolm*Mxaolm + Mxaolm*Mxaolm + Ndim + (9*Mxaolm+1)/2
         need1 = max(need1,need)
      endif
C
      need = Natoms*Natoms + Natoms + Natoms*Natoms + Ndim*Ndim + Ndim
      need1 = max(need1,need)
C
      need = Natoms*Natoms + Ndim*Ndim + Ndim
      need1 = max(need1,need)
C
      if ( Jprint(9).ne.0 ) then
         need = Natoms*Natoms + Ndim*Ndim + Ndim*Ndim + Ndim*(Ndim+5)
         need1 = max(need1,need)
      endif
C
      need1 = need1 + need0
C
C  compute storage for natural bond orbital analysis:
C
      need2 = 0
      if ( Jprint(1).eq.0 ) then
         if ( ioinqr(Iwtnab).ne.iread ) then
            need = Natoms*Natoms + Ndim + 3*Ndim + Mxao*Ndim + Ndim +
     &             Mxbo*Mxbo + Mxbo*Mxbo + Mxbo + Mxbo + Mxao*Mxao +
     &             Mxao*Mxao + Mxao + Mxao + Mxao + Natoms*Natoms
         else
            need = Natoms*Natoms + Ndim + 3*Ndim
         endif
         need2 = max(need2,need)
C
         if ( .not.Ortho ) then
            need = Natoms*Natoms + 4*Ndim*Ndim + Mxao + 3*Ndim
            need2 = max(need2,need)
         endif
C
         need = Natoms*Natoms + Ndim + Mxao + Ndim*Ndim + Ndim*Ndim +
     &          Ndim + Ndim
         need2 = max(need2,need)
C
         need = Natoms*Natoms + Ndim + Ndim + Ndim + Ndim*Ndim
         need2 = max(need2,need)
C
         if ( Jprint(36).ne.0 ) then
            need = Natoms*Natoms + Ndim + 3*Natoms + Ndim*Ndim +
     &             Ndim*Ndim + Ndim
            need2 = max(need2,need)
         endif
C
         need = Natoms*Natoms + Ndim + Ndim*Ndim + Ndim*Ndim +
     &          Ndim*(Ndim+5)
         need2 = max(need2,need)
C
         if ( Jprint(6).ne.0 ) then
            need = Natoms*Natoms + Ndim + Ndim*Ndim + Ndim + Natoms +
     &             Ndim
            need2 = max(need2,need)
         endif
C
C  compute storage for natural localized molecular orbital analysis:
C
         need3 = 0
         if ( Jprint(8).ne.0 ) then
            need = Ndim + Ndim + Ndim*Ndim + Ndim*Ndim
            need3 = max(need3,need)
C
            need = Ndim + Ndim + Ndim + Natoms*Natoms + Natoms*Natoms +
     &             Ndim*Natoms + Ndim*Natoms*(Natoms-1)/2 + Ndim*Ndim
            need3 = max(need3,need)
C
            need = Ndim*Ndim + Ndim*Ndim + Ndim*(Ndim+5)
            need3 = max(need3,need)
C
            if ( Jprint(46).ne.0 ) then
               need = Ndim*Ndim + Ndim*Ndim + Ndim*Ndim + Ndim*Ndim +
     &                Ndim*Ndim + Ndim*Ndim + (Ndim+1)/2
               need3 = max(need3,need)
            endif
         endif
      endif
C
C  print scratch storage requirements:
C
      if ( Iprint.ge.0 ) then
         if ( Jprint(1).ne.0 ) then
            need2 = 0
            need3 = 0
            write (Lfnpr,99001) need1 , MEMORY
         elseif ( Jprint(8).ne.0 ) then
            write (Lfnpr,99003) need1 , need2 , need3 , MEMORY
         else
            need3 = 0
            write (Lfnpr,99002) need1 , need2 , MEMORY
         endif
      endif
      if ( need1.gt.MEMORY .or. need2.gt.MEMORY .or. need3.gt.MEMORY )
     &     then
C
         write (Lfnpr,99004)
         stop
C
99001    format (/1x,'Storage needed:',i6,' in NPA (',i7,' available)')
99002    format (/1x,'Storage needed:',i6,' in NPA,',i6,' in NBO (',i7,
     &           ' available)')
99003    format (/1x,'Storage needed:',i6,' in NPA,',i6,' in NBO,',i6,
     &           ' in NLMO (',i7,' available)')
99004    format (/1x,'*** Not enough core storage is available ***'/)
      endif
      return
      end
@* INDEX.
