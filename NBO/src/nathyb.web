@*nathyb.
\section*{\sf Dummy Arguments}  \begin{description}

\item[OUTPUT:] DM
\item[OUTPUT:] T
\item[INPUT:] GUIDE
\item[OUTPUT:] BNDOCC
\item[OUTPUT:] POL
\item[OUTPUT:] Q
\item[OUTPUT:] V
\item[INPUT:] BLK
\item[INPUT:] C
\item[INPUT:] EVAL
\item[OUTPUT:] BORB
\item[PASSED:] P
\item[PASSED:] TA
\item[PASSED:] HYB
\item[PASSED:] VA
\item[PASSED:] VB
\item[OUTPUT:] TOPO

\end{description} \section*{\sf Common Variables}  \begin{description}

\item[Modifies]    IATHY   INO     IORDER  JPRINT  LABEL
\item[Transmits as argument]  IATNO   JORDER  LARC    LFNPR   MXBO    NATOMS  NBAS
             NDIM
\item[Uses]  CRTSET  IATNO   IBXM    INO     IORDER  ISPIN   IW3C
             IWDETL  JORDER  JPRINT  LABEL   LARC    LFNPR   LL
             LSTOCC  MXAO    MXBO    NATOMS  NBAS    NDIM    NORBS
             PRJSET  THRSET  UL

\end{description}  \section*{\sf External Subprograms}  \begin{description}

\item[Calls]       AUGMNT  CORE    CYCLES  DEPLET  FORMT   FRMPRO  IWPRJ
             JACOBI  LOAD    NAMEAT  ORTHYB  PRJEXP  RANK    REPOL
             STASH
\item[Called by]   NBODRV

\end{description}
@a
C****************************************************************************
C
C  routines called by the nbo/nlmo drivers:
C
C      subroutine nathyb(dm,t,guide,bndocc,pol,q,v,blk,c,eval,borb,
C     +                                       p,ta,hyb,va,vb,topo)
C      subroutine chsdrv(dm,t,guide,bndocc,pol,q,v,blk,c,eval,borb,
C     +                                       p,ta,hyb,va,vb,topo)
C      subroutine choose(dm,t,guide,bndocc,pol,q,v,blk,c,eval,borb,
C     +                                  p,ta,hyb,va,vb,topo,iflg)
C      subroutine srtnbo(t,bndocc)
C      subroutine xcited(dm,t,hyb,thyb,s,occ,scr,iscr)
C      subroutine anlyze(t,bndocc,hyb,hycoef,thyb)
C      subroutine htype(hyb,ltyp,mxao,nh,coef,pct,nl,isgn)
C      subroutine frmhyb(hyb,thyb,coef,hycoef,kl,ku,nhyb)
C      subroutine hybdir(bndocc,atcoor,thyb,tbnd,scr)
C      subroutine hybcmp(xyz,pcent,ihyb,jctr,hyb)
C      subroutine fndmol(iatoms)
C      subroutine nbocla(bndocc,accthr)
C      subroutine fnboan(bndocc,f,molnbo)
C      subroutine nbosum(f,bndocc,list,lista,scr)
C      subroutine getdel(ibo,occ,thr1,thr2,nl,list,del,deloc,iflg)
C      subroutine dlcstr(ibo,il,nl,list,ml,istr)
C      subroutine nlmo(n,a,eval,evec,tsym,reson,nocc,ialarm)
C      subroutine lmoanl(t,s,reson,occ,ts,border,owbord,atlmo,siab,nocc,nab)
C      subroutine dipanl(dm,t,c,tnbo,dx,dy,dz,scr,index)
C      subroutine dipele(dxyz,c,t,scr,eta,nocc,index)
C      subroutine dipnuc(dx,dy,dz,atcoor,eta,nocc)
C
C****************************************************************************
      subroutine nathyb(DM,T,GUIDE,BNDOCC,POL,Q,V,BLK,C,EVAL,BORB,P,TA,
     &                  HYB,VA,VB,TOPO)
C****************************************************************************
      implicit none
      double precision Accthr , Athr , BLK , BNDOCC , BORB , C ,
     &                 crthrs , Crtset , DM , Dthr , E2thr , Ethr ,
     &                 EVAL , four , gmax , gthrsh , GUIDE , HYB ,
     &                 hybexp , occ
      double precision occi , occmx , oldprj , one , P , POL , prjinc ,
     &                 Prjset , prjthr , pt8 , pt99 , Pthr , Q , T ,
     &                 TA , tenth , thresh , Thrset , TOPO , totele
      double precision two , twop , V , VA , VB , zero , zerop , zeropm
      integer i , i1st , I3ctr , ia , ia1 , iab , iaccep , ialarm ,
     &        iat , iat1 , iat2 , iat3 , Iatcr , Iathy , Iatno , iaugm ,
     &        ib , ib1 , ibd , iblnk
      integer ibo , Ibxm , ic , ic1 , Ichoos , icnt , icont , iflg ,
     &        ihyb , ilow , Ino , inxt , iocc , iocclp , Iorder ,
     &        Iprin , Iprint , Ipseud , iptr , ir
      integer irnk , iryd , Ispin , istar , iter , iula , Iw3c ,
     &        Iwapol , Iwcubf , Iwdetl , Iwdm , Iwfock , Iwhybs ,
     &        Iwmulp , Iwpnao , iwprj , Iwtnab , Iwtnao , Iwtnbo , Iznuc
      integer j , jcnt , Jcore , Jorder , Jprint , jptr , k , kflg ,
     &        Kopt , kptr , Label , Larc , lcr , Lfnao , Lfnarc ,
     &        Lfndaf , Lfndef , Lfndm , Lfnin , Lfnmo
      integer Lfnnab , Lfnnao , Lfnnbo , Lfnnho , Lfnnlm , Lfnpna ,
     &        Lfnpnb , Lfnpnh , Lfnpnl , Lfnppa , Lfnpr , Ll , lla ,
     &        lry , Lstocc , Ltyp , MAXATM , MAXBAS , Munit , Mxao
      integer Mxaolm , Mxbo , N3ctr , na1 , nab , nam , name , nameat ,
     &        Naoctr , Naol , Natoms , naugm , nb , Nbas , Nbotyp ,
     &        Nbouni , nctr , Ndim , nel , nexlp
      integer nmb , nocc , nopval , norb , Norbs , nstart , Ntopo
C
C  construct orthogonal matrix t for transformation from ao's to
C  natural hybrid bond orbitals using input density matrix dm.
C
C  required input includes:
C        dm = density matrix in orthonormal atomic orbital basis;
C                  real(1,ndim;1,ndim)
C      nbas = no. of orbitals = actual dimension of dm,s,t,naol,dmt
C    natoms = no. of atoms (not including ghosts) in the molecule
C     iatno = list of atomic numbers
C    naoctr = orbital label list.  naoctr(i)=iat if NAO  \# i is on atom iat
C                integer(1,ndim).  naos of given atom grouped together.
C      iw3c = 1 if program is to search for 3-center bonds,
C           = 0 otherwise
C     guide = wiberg atom-atom bond index matrix, used as guide for NBO search
C
C  output:
C         t = bond orbital transformation matrix (ndim,ndim).
C                rows are labelled by naos, columns by nbos.
C     label = list of bond orbital labels
C      ibxm = permutation list of bond orbital labels (very important!)
C
      logical detail , nobond , first
      logical Rohf , Uhf , Ci , Open , Complx , Alpha , Beta , Mcscf ,
     &        Auhf , Ortho
      integer Ul
      parameter (MAXATM=99,MAXBAS=500)
      common /nbflag/ Rohf , Uhf , Ci , Open , Complx , Alpha , Beta ,
     &                Mcscf , Auhf , Ortho
      common /nbinfo/ Ispin , Natoms , Ndim , Nbas , Mxbo , Mxao ,
     &                Mxaolm , Munit
      common /nbatom/ Iatno(MAXATM) , Ino(MAXATM) , Norbs(MAXATM) ,
     &                Ll(MAXATM) , Ul(MAXATM) , Iznuc(MAXATM) ,
     &                Iatcr(MAXATM)
      common /nbnao / Naoctr(MAXBAS) , Naol(MAXBAS) , Ltyp(MAXBAS) ,
     &                Iprin(MAXBAS)
      common /nbbas / Label(MAXBAS,6) , Nbouni(MAXBAS) , Nbotyp(MAXBAS)
     &                , Lstocc(MAXBAS) , Ibxm(MAXBAS) , Larc(MAXBAS) ,
     &                Iathy(MAXBAS,3)
      common /nbopt / Iwdm , Iw3c , Iwapol , Iwhybs , Iwpnao , Iwtnao ,
     &                Iwtnab , Iwtnbo , Iwfock , Iwcubf , Ipseud ,
     &                Kopt , Iprint , Iwdetl , Iwmulp , Ichoos , Jcore ,
     &                Jprint(60)
      common /nbio  / Lfnin , Lfnpr , Lfnao , Lfnpna , Lfnnao , Lfnpnh ,
     &                Lfnnho , Lfnpnb , Lfnnbo , Lfnpnl , Lfnnlm ,
     &                Lfnmo , Lfndm , Lfnnab , Lfnppa , Lfnarc ,
     &                Lfndaf , Lfndef
      common /nbthr / Thrset , Prjset , Accthr , Crtset , E2thr , Athr ,
     &                Pthr , Ethr , Dthr
      common /nbtopo/ Iorder(MAXATM) , Jorder(MAXATM) ,
     &                Ntopo(MAXATM,MAXATM) , N3ctr , I3ctr(10,3)
      dimension DM(Ndim,Ndim) , T(Ndim,Ndim) , V(Ndim) , BORB(Mxbo) ,
     &          POL(Ndim,3) , BNDOCC(Ndim) , name(3) , hybexp(3) ,
     &          Q(Mxao,Ndim) , BLK(Mxbo,Mxbo) , EVAL(Mxbo) ,
     &          C(Mxbo,Mxbo) , P(Mxao,Mxao) , TA(Mxao,Mxao) , HYB(Mxao)
     &          , VA(Mxao) , VB(Mxao) , GUIDE(Natoms,Natoms) ,
     &          TOPO(Natoms*Natoms)
      data gthrsh/1.5D-1/
      data istar , iblnk/'*' , ' '/
      data name/'LP' , 'BD' , '3C'/
      data lry , lcr/'RY' , 'CR'/
      data zero , zerop , tenth , one , two , four/0.D0 , 1.D-5 ,
     &     0.1D0 , 1.0D0 , 2.0D0 , 4.0D0/
      data twop/2.0001D0/
      data pt8 , pt99/0.8D0 , 0.99D0/
C
C  prjinc, the amount to increase prjthr by if problems with linear
C  dependency between the hybrids arise.
C
      data prjinc/0.05D0/
C
      nopval(i) = Norbs(i) - Ino(i)
C
      detail = .false.
      if ( Iwdetl.ne.0 ) detail = .true.
      nobond = .false.
      if ( Jprint(10).ne.0 ) nobond = .true.
C
C  initial iteration loop:  if no satisfactory lewis structure (all
C  antibond occupancies < 0.1) for thresh = 1.90, thresh is decremented
C  up to 4 times by 0.1 in search of a better structure.  if the dm is
C  not spinless, thresh is set to 0.90 and is decremented as above.
C
      prjthr = abs(Prjset)
      thresh = abs(Thrset)
      if ( Ispin.ne.0 ) thresh = thresh - one
      if ( nobond ) thresh = one
      if ( nobond .and. (Ispin.ne.0) ) thresh = one/two
      if ( Ispin.ne.0 ) gthrsh = gthrsh/four
C
C  determine the atom ordering for the initial search for bonds:
C
      if ( Natoms.eq.1 ) then
         Iorder(1) = 1
         goto 500
      endif
C
C  find the two atoms which have the largest bond index:
C
      gmax = zero
      do 100 j = 2 , Natoms
         do 50 i = 1 , j - 1
            if ( GUIDE(i,j).gt.gmax ) then
               gmax = GUIDE(i,j)
               iat = i
            endif
 50      continue
 100  continue
      Iorder(1) = iat
C
C  add atoms to iorder according to these connectivities:
C
      icnt = 1
      inxt = icnt
      jcnt = icnt
 200  iptr = inxt
      i1st = 1
      do 300 i = 1 , Natoms
         TOPO(i) = GUIDE(i,Iorder(iptr))
 300  continue
      call rank(TOPO,Natoms,Natoms,Jorder)
      jptr = 1
 400  if ( TOPO(jptr).gt.pt8 ) then
         iflg = 1
         do 450 i = 1 , icnt
            if ( Iorder(i).eq.Jorder(jptr) ) iflg = 0
 450     continue
         if ( iflg.eq.1 ) then
            icnt = icnt + 1
            Iorder(icnt) = Jorder(jptr)
            if ( i1st.eq.1 ) then
               i1st = 0
               inxt = icnt
            endif
         endif
      else
C
         if ( i1st.eq.1 ) then
            jcnt = jcnt + 1
            inxt = jcnt
            if ( inxt.gt.Natoms ) goto 500
            if ( inxt.gt.icnt ) then
               kptr = 0
 460           kptr = kptr + 1
               kflg = 1
               do 470 i = 1 , icnt
                  if ( Iorder(i).eq.kptr ) kflg = 0
 470           continue
               if ( kflg.eq.0 ) goto 460
               icnt = icnt + 1
               Iorder(icnt) = kptr
            endif
         endif
         goto 200
      endif
      jptr = jptr + 1
      goto 400
C
 500  iter = 0
      ialarm = 0
 600  if ( ialarm.eq.0 ) iter = iter + 1
C
C  store density matrix in upper triangle of t:
C
      do 700 j = 1 , Nbas
         do 650 i = 1 , j
            T(i,j) = DM(i,j)
 650     continue
 700  continue
C
C  zero arrays q, pol, iathy, ino, and label:
C
      do 1000 i = 1 , Nbas
         do 750 k = 1 , 2
            Label(i,k) = iblnk
 750     continue
         do 800 k = 3 , 6
            Label(i,k) = 0
 800     continue
         do 850 k = 1 , 3
            POL(i,k) = zero
            Iathy(i,k) = 0
 850     continue
         do 900 k = 1 , Mxao
            Q(k,i) = zero
 900     continue
 1000 continue
      do 1100 i = 1 , Natoms
         Ino(i) = 0
 1100 continue
C
C  remove core orbitals from the density matrix:
C
      ibd = 0
      call core(DM,T,BORB,POL,Q,HYB,BNDOCC,ibd,detail,Lfnpr)
C
C  main NHO loops
C  --------------
C  doubly occupied (iocc=1) or singly occupied (iocc=2) nho's
C  if ispin.ne.0, search is only for singly occupied nbos (iocc=1):
C
      occmx = thresh
C
C  main NHO loops over singles, doubles, and triples of atoms:
C
      na1 = Natoms + 1
      do 1200 ia1 = 1 , na1
         ia = ia1 - 1
         if ( (ia.le.0) .or. (nopval(Iorder(ia)).gt.0) ) then
            do 1120 ib1 = 1 , na1
               ib = ib1 - 1
               if ( (ib.le.0) .or. (nopval(Iorder(ib)).gt.0) ) then
                  do 1110 ic1 = 2 , na1
                     ic = ic1 - 1
                     if ( (ic.le.0) .or. (nopval(Iorder(ic)).gt.0) )
     &                    then
                        if ( ia.ne.0 ) then
C
C  3-center bonds:
C
                           if ( Iw3c.ne.1 ) goto 1300
                           nctr = 3
                           iat1 = Iorder(ia)
                           iat2 = Iorder(ib)
                           iat3 = Iorder(ic)
                           if ( iat1.ge.iat2 ) goto 1120
                           if ( iat2.ge.iat3 ) goto 1110
                           if ( GUIDE(iat1,iat2).le.gthrsh ) then
                              if ( GUIDE(iat1,iat3).le.gthrsh ) then
                                 if ( GUIDE(iat2,iat3).le.gthrsh )
     &                                goto 1110
                              endif
                           endif
                        elseif ( ib.ne.0 ) then
C
C  bond pairs:
C
                           if ( nobond ) goto 1110
                           nctr = 2
                           iat1 = Iorder(ib)
                           iat2 = Iorder(ic)
                           iat3 = 0
                           if ( iat2.le.iat1 ) goto 1110
                           if ( GUIDE(iat1,iat2).lt.gthrsh ) goto 1110
                        else
C
C  lone pairs:
C
                           nctr = 1
                           iat1 = Iorder(ic)
                           iat2 = 0
                           iat3 = 0
                        endif
C
C  deplete dm of one(two) center orbitals if search for two(three)
C  center orbitals is beginning:
C
                        if ( iwprj(nctr).ne.0 )
     &                       call deplet(DM,T,Q,POL,BORB,BNDOCC,ibd)
C
C  load proper atomic blocks of dm into blk:
C
                        call load(DM,iat1,iat2,iat3,BLK,nb)
C
C  diagonalize blk:
C
                        call jacobi(nb,BLK,EVAL,C,Mxbo,Mxbo,1)
C
C  rank eigenvectors by occupancy eigenvalue:
C
                        call rank(EVAL,nb,Mxbo,Larc)
                        if ( detail ) write (Lfnpr,99005) iat1 , iat2 ,
     &                       iat3
                        if ( detail ) write (Lfnpr,99006) thresh
                        if ( detail ) write (Lfnpr,99007)
     &                       (EVAL(irnk),irnk=1,nb)
                        iaccep = 0
                        do 1108 irnk = 1 , nb
                           ir = Larc(irnk)
                           occ = EVAL(irnk)
                           do 1102 i = 1 , nb
                              BORB(i) = C(i,ir)
 1102                      continue
                           if ( detail ) write (Lfnpr,99008) irnk , occ
                           if ( detail ) write (Lfnpr,99009)
     &                          (BORB(i),i=1,nb)
C
C  throw out orbital if occupancy is less than the threshhold "occmx":
C
                           if ( occ.lt.occmx ) goto 1110
C
C  check to see that bond orbital "borb" doesn't contain previously used
C  hybrids:
C
                           if ( nctr.ne.1 ) then
                              call prjexp(BORB,iat1,iat2,iat3,Q,P,TA,
     &                           HYB,VA,VB,hybexp)
                              if ( detail ) then
                                 do 1104 ihyb = 1 , nctr
                                    write (Lfnpr,99010) ihyb ,
     &                                 hybexp(ihyb)
 1104                            continue
                              endif
                              do 1106 ihyb = 1 , nctr
                                 if ( hybexp(ihyb).lt.prjthr ) goto 1108
 1106                         continue
                           endif
                           ibd = ibd + 1
                           iaccep = iaccep + 1
C
C  decompose "borb" into its constituent atomic hybrids and store in q:
C
                           call stash(BORB,ibd,iat1,iat2,iat3,POL,Q,HYB)
C
C  construct bond orbital labels:
C
                           Label(ibd,1) = name(nctr)
                           Label(ibd,2) = iblnk
                           Label(ibd,3) = iaccep
                           Label(ibd,4) = iat1
                           Label(ibd,5) = iat2
                           Label(ibd,6) = iat3
                           BNDOCC(ibd) = occ
                           if ( detail ) write (Lfnpr,99011) ibd ,
     &                          (Label(ibd,i),i=1,3)
 1108                   continue
                     endif
 1110             continue
               endif
 1120       continue
         endif
 1200 continue
C
C  symmetric orthogonalization of principal hybrids:
C
 1300 call orthyb(Q,BLK,TA,EVAL,C,ialarm,0)
C
C   ialarm sounds the alarm that there is linear dependency between some
C   of the hybrids. the remedy is to increase prjthr and repeat the nbo
C   search. ialarm is equal to the number of the violating atom.
C
      if ( ialarm.ne.0 ) then
         oldprj = prjthr
         prjthr = oldprj + prjinc
         if ( Jprint(5).ne.0 ) write (Lfnpr,99012) ialarm , oldprj ,
     &                                prjthr
         if ( prjthr.ge.pt99 ) then
            write (Lfnpr,99013) ialarm
            Jprint(1) = -1
            return
         endif
         goto 1600
      endif
C
C  augment open-valence atoms with non-arbitrary hybrids orthogonal to
C  those found previously:
C
      do 1400 ia = 1 , Natoms
         if ( nopval(ia).gt.0 ) then
C
C  iula: upper limit of naos on atom. find nmb, the number of natural
C  minimal basis functions on the atom:
C
            lla = Ll(ia)
            iula = Ul(ia)
            nmb = 0
            do 1320 i = lla , iula
               if ( Lstocc(i).eq.1 ) nmb = nmb + 1
 1320       continue
C
C  find the number of bond, core, and lone pair hybrids on the atom, iocc:
C  also find iocclp, number of core and lone pair orbitals already found
C  on ia, for use in labelling the extra lone pairs below:
C
            iocc = 0
            iocclp = 0
            do 1340 ib = 1 , ibd
               if ( (Label(ib,4).eq.ia) .or. (Label(ib,5).eq.ia) .or.
     &              (Label(ib,6).eq.ia) ) then
                  iocc = iocc + 1
                  if ( Label(ib,1).eq.name(1) ) iocclp = iocclp + 1
               endif
 1340       continue
C
C  nexlp: number of extra (low occupancy) lp orbitals on atom iat. (this
C  is the number of low occupancy orbitals with valence shell character)
C  set nexlp to zero if (nmb-iocc) is less than zero in order that the
C  orbitals are not miscounted!!
C
            nexlp = nmb - iocc
            if ( nexlp.lt.0 ) nexlp = 0
C
            nocc = Ino(ia)
            call frmpro(P,ia,Q,nocc,TA,VA,VB)
            norb = Norbs(ia)
            naugm = norb - nocc
            call augmnt(P,BLK,C,EVAL,DM,TA,BORB,V,Larc,ia,nocc,norb)
C
C  stash and label extra lone pairs that augmnt put in blk: (these ar
C  taken to be the highest occupied orbitals, which augmnt places first)
C
            do 1360 iaugm = 1 , nexlp
               do 1350 j = 1 , norb
                  BORB(j) = BLK(j,iaugm)
 1350          continue
               ibd = ibd + 1
               call stash(BORB,ibd,ia,0,0,POL,Q,HYB)
               Label(ibd,1) = name(1)
               Label(ibd,2) = iblnk
               Label(ibd,3) = iaugm + iocclp
               Label(ibd,4) = ia
               Label(ibd,5) = 0
               Label(ibd,6) = 0
 1360       continue
C
C  stash and label the rydberg orbitals that augmnt put in blk:
C
            iryd = 0
            nstart = nexlp + 1
            do 1380 iaugm = nstart , naugm
               do 1370 j = 1 , norb
                  BORB(j) = BLK(j,iaugm)
 1370          continue
               ibd = ibd + 1
               iryd = iryd + 1
               call stash(BORB,ibd,ia,0,0,POL,Q,HYB)
               Label(ibd,1) = lry
               Label(ibd,2) = istar
               Label(ibd,3) = iryd
               Label(ibd,4) = ia
               Label(ibd,5) = 0
               Label(ibd,6) = 0
 1380       continue
         endif
 1400 continue
C
C  include antibond labels:
C
      ibo = ibd
      do 1500 i = 1 , ibo
C
C  exit loop if label(i,1) is 'lp', 'ry', or 'cr':
C
         if ( Label(i,1).ne.name(1) ) then
            if ( Label(i,1).ne.lry ) then
               if ( Label(i,1).ne.lcr ) then
                  nab = 1
                  if ( Label(i,1).eq.name(3) ) nab = 2
                  do 1405 iab = 1 , nab
                     ibd = ibd + 1
                     do 1402 j = 1 , 6
                        Label(ibd,j) = Label(i,j)
 1402                continue
                     Label(ibd,2) = istar
 1405             continue
               endif
            endif
         endif
 1500 continue
C
C  replace density matrix dm from t:
C
 1600 do 1700 j = 1 , Nbas
         do 1650 i = 1 , j
            DM(i,j) = T(i,j)
            DM(j,i) = DM(i,j)
            T(j,i) = zero
            T(i,j) = zero
 1650    continue
 1700 continue
C
C  remember the alarm!
C
      if ( ialarm.ne.0 ) goto 600
C
C  miscounted bond orbitals...exit for open shell:
C
      if ( ibd.ne.Nbas ) then
         write (Lfnpr,99001) thresh , ibd , Nbas
         write (Lfnpr,99002) (i,(Label(i,j),j=1,6),i=1,ibd)
         stop
      endif
C
C  find new polarization parameters for orthonormal hybrids:
C
      call repol(DM,Q,POL,BLK,EVAL,C,ibd)
C
C  form final t-nab (nao to NBO transformation) from orthonormal
C  hybrids:
C
      call formt(T,Q,POL)
C
C  find occupancies, find total number of electrons and occupied orbitals:
C
      totele = zero
      do 1800 i = 1 , Nbas
         occi = zero
         do 1750 j = 1 , Nbas
            do 1720 k = 1 , Nbas
               occi = occi + T(j,i)*DM(j,k)*T(k,i)
 1720       continue
 1750    continue
         if ( dabs(occi).lt.zerop ) occi = zero
         if ( occi.gt.twop ) goto 2000
         zeropm = -zerop
         if ( occi.lt.zeropm ) goto 2000
         BNDOCC(i) = occi
         V(i) = occi
         totele = totele + BNDOCC(i)
 1800 continue
      nel = totele + tenth
      if ( abs(totele-nel).gt.1E-4 ) then
C
C  total number of electrons is not an integer:
C
         write (Lfnpr,99004) totele
         Jprint(1) = -1
         return
C
99001    format (/,1x,'For an occupancy threshold of ',f4.2,
     &           ' the search',' for NBOs found',/,1x,i3,
     &           ' orbitals orbitals rather than ',i4)
99002    format (3x,'Label ',i3,':',a3,a1,i2,3I3)
99003    format (/,1x,'A bond orbital with an occupancy of ',f8.5,
     &           ' electrons was found!',/,1x,
     &           'Please check you input data.')
99004    format (/,1x,'The total number of electron is not an integer:',
     &           f10.5,/,1x,'Please check your input data.')
99005    format (/,1x,'Search of DM block between the following atoms:',
     &           3I4)
99006    format (6x,'Select orbitals with eigenvalue > ',f9.6)
99007    format (6x,8F9.6)
99008    format (6x,'Eigenvector (',i2,') has occupancy ',f9.6,':')
99009    format (11x,8F7.4)
99010    format (11x,'Hybrid ',i1,' in eigenvector has a projection ',
     &           'expectation of ',f6.3)
99011    format (11x,'*** NBO accepted: Number',i3,'.   Label:',a2,a1,
     &           '(',i2,')')
99012    format (/4x,'The hybrids found for atom ',i2,' are linearly ',
     &           'dependent.  Remedy: PRJTHR',/,4x,
     &           'will be raised from',f6.3,' to',f6.3,
     &           ' and the NBO search repeated',/)
99013    format (//,1x,'Linearly independent hybrids for atom',i3,
     &           ' cannot be found.',/,1x,'The NBO program must abort.')
99014    format (/,1x,'WARNING:',i3,' low occupancy (<',f6.4,
     &           'e) core orbitals ','found on ',a2,i2)
99015    format (/,1x,'WARNING:',i3,' low occupancy (<',f6.4,
     &           'e) core orbital  ','found on ',a2,i2)
99016    format (1x,'        ',i3,' low occupancy (<',f6.4,
     &           'e) core orbitals ','found on ',a2,i2)
99017    format (1x,'        ',i3,' low occupancy (<',f6.4,
     &           'e) core orbital  ','found on ',a2,i2)
      else
         totele = nel
         nocc = nel
         if ( Ispin.eq.0 ) nocc = nocc/2 + mod(nocc,2)
C
C  make sure all but the nocc highest occupied nbos are starred:
C
         call rank(V,Nbas,Ndim,Larc)
         do 1850 i = 1 , nocc
            ir = Larc(i)
            Label(Ibxm(ir),2) = iblnk
 1850    continue
         do 1900 i = nocc + 1 , Nbas
            ir = Larc(i)
            Label(Ibxm(ir),2) = istar
 1900    continue
C
C  determine whether this is a good resonance structure:
C
         call cycles(iter,thresh,GUIDE,BNDOCC,TOPO,icont)
         if ( icont.eq.0 ) then
            Jprint(1) = -1
            return
         endif
         if ( icont.eq.-1 ) goto 600
         if ( icont.eq.1 ) goto 600
C
C  before final return, write out info about core orbitals which
C  were isolated in subroutine core:
C
         crthrs = Crtset
         if ( Ispin.ne.0 ) crthrs = crthrs - one
         first = .true.
         do 1950 iat = 1 , Natoms
            ilow = 0
            do 1920 i = 1 , Nbas
               if ( Label(Ibxm(i),1).eq.lcr .and. Label(Ibxm(i),4)
     &              .eq.iat .and. BNDOCC(i).lt.crthrs ) ilow = ilow + 1
 1920       continue
            if ( ilow.ne.0 ) then
               if ( first ) then
                  first = .false.
                  nam = nameat(Iatno(iat))
                  if ( ilow.ne.1 ) then
                     if ( Jprint(5).eq.1 ) write (Lfnpr,99014) ilow ,
     &                    crthrs , nam , iat
                  else
                     if ( Jprint(5).eq.1 ) write (Lfnpr,99015) ilow ,
     &                    crthrs , nam , iat
                  endif
               else
                  nam = nameat(Iatno(iat))
                  if ( ilow.ne.1 ) then
                     if ( Jprint(5).eq.1 ) write (Lfnpr,99016) ilow ,
     &                    crthrs , nam , iat
                  else
                     if ( Jprint(5).eq.1 ) write (Lfnpr,99017) ilow ,
     &                    crthrs , nam , iat
                  endif
               endif
            endif
 1950    continue
         return
      endif
C
C  problems with a bond orbital occupancy:
C
 2000 write (Lfnpr,99003) occi
      Jprint(1) = -1
      return
      end
@* INDEX.
